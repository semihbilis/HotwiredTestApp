{"version":3,"file":"app.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6BAA6B,IAAI;AAChE,+CAA+C,mCAAmC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,4BAA4B,eAAe,uBAAuB;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD;AACnD;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0BAA0B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,oCAAoC,wBAAwB;AACrG;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kDAAkD,sBAAsB,gBAAgB;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,KAAK;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,OAAO,cAAc,OAAO;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,GAAG;AACjD;AACA;AACA;AACA;AACA,oBAAoB,KAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,YAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B;AACA;AACA;AACA,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;AACA;AACA,gBAAgB,iDAAiD;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,iBAAiB;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD,oBAAoB,kCAAkC,KAAK,kCAAkC;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,uBAAuB;AACzE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,aAAa,2CAA2C,cAAc,0CAA0C,GAAG;AACpK,SAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,KAAK;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4FAA4F,gCAAgC;AAC5I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2BAA2B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA,kCAAkC,8DAA8D;AAChG;AACA;AACA;AACA,kCAAkC,kDAAkD;AACpF;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA,kCAAkC,8DAA8D;AAChG;AACA;AACA,kCAAkC,kDAAkD;AACpF;AACA;AACA;AACA,8BAA8B,gEAAgE;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,GAAG;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC;AACA,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA,yGAAyG,yBAAyB;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA,uCAAuC,oBAAoB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,8CAA8C;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8BAA8B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2CAA2C;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,yCAAyC;AAClH;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,0BAA0B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F,QAAQ;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,gCAAgC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,wBAAwB,oBAAoB,oBAAoB;AACzG;AACA;AACA,gDAAgD,UAAU,oBAAoB,oBAAoB;AAClG;AACA;AACA;AACA,yCAAyC,UAAU,8BAA8B;AACjF;AACA;AACA;AACA;AACA;AACA,iDAAiD,UAAU,iBAAiB,oBAAoB;AAChG;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,wCAAwC,UAAU,mCAAmC;AACrF;AACA;AACA,0DAA0D,sDAAsD;AAChH;AACA;AACA,8CAA8C,eAAe;AAC7D;AACA;AACA,gDAAgD,UAAU,eAAe,mCAAmC;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yBAAyB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,aAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA,4BAA4B,yBAAyB;AACrD;AACA,uCAAuC;AACvC,+CAA+C,0DAA0D;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,GAAG;AACpF;AACA;AACA,+FAA+F,GAAG;AAClG;AACA;AACA;AACA,uEAAuE,GAAG;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,WAAW;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ,0HAA0H;AAC7K,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,2CAA2C,QAAQ,8GAA8G;AACjK,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB,IAAI,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,iCAAiC;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AAC6N;;;;;;;;;;;;AC3wG7N;;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;ACNA;CAIA;AACA;;AACAA,0DAAA,GAAsB,IAAtB,EAEA;;AACAG,QAAQ,CAACC,gBAAT,CAA0B,YAA1B,EAAwC,UAAUC,CAAV,EAAa;EACjDC,OAAO,CAACC,GAAR,CAAY,YAAZ,EAA0BF,CAA1B;AACH,CAFD;AAIAF,QAAQ,CAACC,gBAAT,CAA0B,aAA1B,EAAyC,UAAUC,CAAV,EAAa;EAClDC,OAAO,CAACC,GAAR,CAAY,aAAZ,EAA2BF,CAA3B;AACH,CAFD;AAIAF,QAAQ,CAACC,gBAAT,CAA0B,kBAA1B,EAA8C,UAAUC,CAAV,EAAa;EACvDC,OAAO,CAACC,GAAR,CAAY,kBAAZ,EAAgCF,CAAhC;AACH,CAFD,E","sources":["webpack://cardtypeapp/./node_modules/@hotwired/turbo/dist/turbo.es2017-esm.js","webpack://cardtypeapp/./src/css/app.css?fd63","webpack://cardtypeapp/webpack/bootstrap","webpack://cardtypeapp/webpack/runtime/define property getters","webpack://cardtypeapp/webpack/runtime/hasOwnProperty shorthand","webpack://cardtypeapp/webpack/runtime/make namespace object","webpack://cardtypeapp/./src/js/app.js"],"sourcesContent":["/*\r\nTurbo 7.1.0\r\nCopyright Â© 2021 Basecamp, LLC\r\n */\r\n(function () {\r\n    if (window.Reflect === undefined || window.customElements === undefined ||\r\n        window.customElements.polyfillWrapFlushCallback) {\r\n        return;\r\n    }\r\n    const BuiltInHTMLElement = HTMLElement;\r\n    const wrapperForTheName = {\r\n        'HTMLElement': function HTMLElement() {\r\n            return Reflect.construct(BuiltInHTMLElement, [], this.constructor);\r\n        }\r\n    };\r\n    window.HTMLElement =\r\n        wrapperForTheName['HTMLElement'];\r\n    HTMLElement.prototype = BuiltInHTMLElement.prototype;\r\n    HTMLElement.prototype.constructor = HTMLElement;\r\n    Object.setPrototypeOf(HTMLElement, BuiltInHTMLElement);\r\n})();\r\n\r\n/**\r\n * The MIT License (MIT)\r\n * \r\n * Copyright (c) 2019 Javan Makhmali\r\n * \r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n * \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n * \r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\r\n\r\n(function(prototype) {\r\n  if (typeof prototype.requestSubmit == \"function\") return\r\n\r\n  prototype.requestSubmit = function(submitter) {\r\n    if (submitter) {\r\n      validateSubmitter(submitter, this);\r\n      submitter.click();\r\n    } else {\r\n      submitter = document.createElement(\"input\");\r\n      submitter.type = \"submit\";\r\n      submitter.hidden = true;\r\n      this.appendChild(submitter);\r\n      submitter.click();\r\n      this.removeChild(submitter);\r\n    }\r\n  };\r\n\r\n  function validateSubmitter(submitter, form) {\r\n    submitter instanceof HTMLElement || raise(TypeError, \"parameter 1 is not of type 'HTMLElement'\");\r\n    submitter.type == \"submit\" || raise(TypeError, \"The specified element is not a submit button\");\r\n    submitter.form == form || raise(DOMException, \"The specified element is not owned by this form element\", \"NotFoundError\");\r\n  }\r\n\r\n  function raise(errorConstructor, message, name) {\r\n    throw new errorConstructor(\"Failed to execute 'requestSubmit' on 'HTMLFormElement': \" + message + \".\", name)\r\n  }\r\n})(HTMLFormElement.prototype);\r\n\r\nconst submittersByForm = new WeakMap;\r\nfunction findSubmitterFromClickTarget(target) {\r\n    const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;\r\n    const candidate = element ? element.closest(\"input, button\") : null;\r\n    return (candidate === null || candidate === void 0 ? void 0 : candidate.type) == \"submit\" ? candidate : null;\r\n}\r\nfunction clickCaptured(event) {\r\n    const submitter = findSubmitterFromClickTarget(event.target);\r\n    if (submitter && submitter.form) {\r\n        submittersByForm.set(submitter.form, submitter);\r\n    }\r\n}\r\n(function () {\r\n    if (\"submitter\" in Event.prototype)\r\n        return;\r\n    let prototype;\r\n    if (\"SubmitEvent\" in window && /Apple Computer/.test(navigator.vendor)) {\r\n        prototype = window.SubmitEvent.prototype;\r\n    }\r\n    else if (\"SubmitEvent\" in window) {\r\n        return;\r\n    }\r\n    else {\r\n        prototype = window.Event.prototype;\r\n    }\r\n    addEventListener(\"click\", clickCaptured, true);\r\n    Object.defineProperty(prototype, \"submitter\", {\r\n        get() {\r\n            if (this.type == \"submit\" && this.target instanceof HTMLFormElement) {\r\n                return submittersByForm.get(this.target);\r\n            }\r\n        }\r\n    });\r\n})();\r\n\r\nvar FrameLoadingStyle;\r\n(function (FrameLoadingStyle) {\r\n    FrameLoadingStyle[\"eager\"] = \"eager\";\r\n    FrameLoadingStyle[\"lazy\"] = \"lazy\";\r\n})(FrameLoadingStyle || (FrameLoadingStyle = {}));\r\nclass FrameElement extends HTMLElement {\r\n    constructor() {\r\n        super();\r\n        this.loaded = Promise.resolve();\r\n        this.delegate = new FrameElement.delegateConstructor(this);\r\n    }\r\n    static get observedAttributes() {\r\n        return [\"disabled\", \"loading\", \"src\"];\r\n    }\r\n    connectedCallback() {\r\n        this.delegate.connect();\r\n    }\r\n    disconnectedCallback() {\r\n        this.delegate.disconnect();\r\n    }\r\n    reload() {\r\n        const { src } = this;\r\n        this.src = null;\r\n        this.src = src;\r\n    }\r\n    attributeChangedCallback(name) {\r\n        if (name == \"loading\") {\r\n            this.delegate.loadingStyleChanged();\r\n        }\r\n        else if (name == \"src\") {\r\n            this.delegate.sourceURLChanged();\r\n        }\r\n        else {\r\n            this.delegate.disabledChanged();\r\n        }\r\n    }\r\n    get src() {\r\n        return this.getAttribute(\"src\");\r\n    }\r\n    set src(value) {\r\n        if (value) {\r\n            this.setAttribute(\"src\", value);\r\n        }\r\n        else {\r\n            this.removeAttribute(\"src\");\r\n        }\r\n    }\r\n    get loading() {\r\n        return frameLoadingStyleFromString(this.getAttribute(\"loading\") || \"\");\r\n    }\r\n    set loading(value) {\r\n        if (value) {\r\n            this.setAttribute(\"loading\", value);\r\n        }\r\n        else {\r\n            this.removeAttribute(\"loading\");\r\n        }\r\n    }\r\n    get disabled() {\r\n        return this.hasAttribute(\"disabled\");\r\n    }\r\n    set disabled(value) {\r\n        if (value) {\r\n            this.setAttribute(\"disabled\", \"\");\r\n        }\r\n        else {\r\n            this.removeAttribute(\"disabled\");\r\n        }\r\n    }\r\n    get autoscroll() {\r\n        return this.hasAttribute(\"autoscroll\");\r\n    }\r\n    set autoscroll(value) {\r\n        if (value) {\r\n            this.setAttribute(\"autoscroll\", \"\");\r\n        }\r\n        else {\r\n            this.removeAttribute(\"autoscroll\");\r\n        }\r\n    }\r\n    get complete() {\r\n        return !this.delegate.isLoading;\r\n    }\r\n    get isActive() {\r\n        return this.ownerDocument === document && !this.isPreview;\r\n    }\r\n    get isPreview() {\r\n        var _a, _b;\r\n        return (_b = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.documentElement) === null || _b === void 0 ? void 0 : _b.hasAttribute(\"data-turbo-preview\");\r\n    }\r\n}\r\nfunction frameLoadingStyleFromString(style) {\r\n    switch (style.toLowerCase()) {\r\n        case \"lazy\": return FrameLoadingStyle.lazy;\r\n        default: return FrameLoadingStyle.eager;\r\n    }\r\n}\r\n\r\nfunction expandURL(locatable) {\r\n    return new URL(locatable.toString(), document.baseURI);\r\n}\r\nfunction getAnchor(url) {\r\n    let anchorMatch;\r\n    if (url.hash) {\r\n        return url.hash.slice(1);\r\n    }\r\n    else if (anchorMatch = url.href.match(/#(.*)$/)) {\r\n        return anchorMatch[1];\r\n    }\r\n}\r\nfunction getAction(form, submitter) {\r\n    const action = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute(\"formaction\")) || form.getAttribute(\"action\") || form.action;\r\n    return expandURL(action);\r\n}\r\nfunction getExtension(url) {\r\n    return (getLastPathComponent(url).match(/\\.[^.]*$/) || [])[0] || \"\";\r\n}\r\nfunction isHTML(url) {\r\n    return !!getExtension(url).match(/^(?:|\\.(?:htm|html|xhtml))$/);\r\n}\r\nfunction isPrefixedBy(baseURL, url) {\r\n    const prefix = getPrefix(url);\r\n    return baseURL.href === expandURL(prefix).href || baseURL.href.startsWith(prefix);\r\n}\r\nfunction locationIsVisitable(location, rootLocation) {\r\n    return isPrefixedBy(location, rootLocation) && isHTML(location);\r\n}\r\nfunction getRequestURL(url) {\r\n    const anchor = getAnchor(url);\r\n    return anchor != null\r\n        ? url.href.slice(0, -(anchor.length + 1))\r\n        : url.href;\r\n}\r\nfunction toCacheKey(url) {\r\n    return getRequestURL(url);\r\n}\r\nfunction urlsAreEqual(left, right) {\r\n    return expandURL(left).href == expandURL(right).href;\r\n}\r\nfunction getPathComponents(url) {\r\n    return url.pathname.split(\"/\").slice(1);\r\n}\r\nfunction getLastPathComponent(url) {\r\n    return getPathComponents(url).slice(-1)[0];\r\n}\r\nfunction getPrefix(url) {\r\n    return addTrailingSlash(url.origin + url.pathname);\r\n}\r\nfunction addTrailingSlash(value) {\r\n    return value.endsWith(\"/\") ? value : value + \"/\";\r\n}\r\n\r\nclass FetchResponse {\r\n    constructor(response) {\r\n        this.response = response;\r\n    }\r\n    get succeeded() {\r\n        return this.response.ok;\r\n    }\r\n    get failed() {\r\n        return !this.succeeded;\r\n    }\r\n    get clientError() {\r\n        return this.statusCode >= 400 && this.statusCode <= 499;\r\n    }\r\n    get serverError() {\r\n        return this.statusCode >= 500 && this.statusCode <= 599;\r\n    }\r\n    get redirected() {\r\n        return this.response.redirected;\r\n    }\r\n    get location() {\r\n        return expandURL(this.response.url);\r\n    }\r\n    get isHTML() {\r\n        return this.contentType && this.contentType.match(/^(?:text\\/([^\\s;,]+\\b)?html|application\\/xhtml\\+xml)\\b/);\r\n    }\r\n    get statusCode() {\r\n        return this.response.status;\r\n    }\r\n    get contentType() {\r\n        return this.header(\"Content-Type\");\r\n    }\r\n    get responseText() {\r\n        return this.response.clone().text();\r\n    }\r\n    get responseHTML() {\r\n        if (this.isHTML) {\r\n            return this.response.clone().text();\r\n        }\r\n        else {\r\n            return Promise.resolve(undefined);\r\n        }\r\n    }\r\n    header(name) {\r\n        return this.response.headers.get(name);\r\n    }\r\n}\r\n\r\nfunction dispatch(eventName, { target, cancelable, detail } = {}) {\r\n    const event = new CustomEvent(eventName, { cancelable, bubbles: true, detail });\r\n    if (target && target.isConnected) {\r\n        target.dispatchEvent(event);\r\n    }\r\n    else {\r\n        document.documentElement.dispatchEvent(event);\r\n    }\r\n    return event;\r\n}\r\nfunction nextAnimationFrame() {\r\n    return new Promise(resolve => requestAnimationFrame(() => resolve()));\r\n}\r\nfunction nextEventLoopTick() {\r\n    return new Promise(resolve => setTimeout(() => resolve(), 0));\r\n}\r\nfunction nextMicrotask() {\r\n    return Promise.resolve();\r\n}\r\nfunction parseHTMLDocument(html = \"\") {\r\n    return new DOMParser().parseFromString(html, \"text/html\");\r\n}\r\nfunction unindent(strings, ...values) {\r\n    const lines = interpolate(strings, values).replace(/^\\n/, \"\").split(\"\\n\");\r\n    const match = lines[0].match(/^\\s+/);\r\n    const indent = match ? match[0].length : 0;\r\n    return lines.map(line => line.slice(indent)).join(\"\\n\");\r\n}\r\nfunction interpolate(strings, values) {\r\n    return strings.reduce((result, string, i) => {\r\n        const value = values[i] == undefined ? \"\" : values[i];\r\n        return result + string + value;\r\n    }, \"\");\r\n}\r\nfunction uuid() {\r\n    return Array.apply(null, { length: 36 }).map((_, i) => {\r\n        if (i == 8 || i == 13 || i == 18 || i == 23) {\r\n            return \"-\";\r\n        }\r\n        else if (i == 14) {\r\n            return \"4\";\r\n        }\r\n        else if (i == 19) {\r\n            return (Math.floor(Math.random() * 4) + 8).toString(16);\r\n        }\r\n        else {\r\n            return Math.floor(Math.random() * 15).toString(16);\r\n        }\r\n    }).join(\"\");\r\n}\r\nfunction getAttribute(attributeName, ...elements) {\r\n    for (const value of elements.map(element => element === null || element === void 0 ? void 0 : element.getAttribute(attributeName))) {\r\n        if (typeof value == \"string\")\r\n            return value;\r\n    }\r\n    return null;\r\n}\r\nfunction markAsBusy(...elements) {\r\n    for (const element of elements) {\r\n        if (element.localName == \"turbo-frame\") {\r\n            element.setAttribute(\"busy\", \"\");\r\n        }\r\n        element.setAttribute(\"aria-busy\", \"true\");\r\n    }\r\n}\r\nfunction clearBusyState(...elements) {\r\n    for (const element of elements) {\r\n        if (element.localName == \"turbo-frame\") {\r\n            element.removeAttribute(\"busy\");\r\n        }\r\n        element.removeAttribute(\"aria-busy\");\r\n    }\r\n}\r\n\r\nvar FetchMethod;\r\n(function (FetchMethod) {\r\n    FetchMethod[FetchMethod[\"get\"] = 0] = \"get\";\r\n    FetchMethod[FetchMethod[\"post\"] = 1] = \"post\";\r\n    FetchMethod[FetchMethod[\"put\"] = 2] = \"put\";\r\n    FetchMethod[FetchMethod[\"patch\"] = 3] = \"patch\";\r\n    FetchMethod[FetchMethod[\"delete\"] = 4] = \"delete\";\r\n})(FetchMethod || (FetchMethod = {}));\r\nfunction fetchMethodFromString(method) {\r\n    switch (method.toLowerCase()) {\r\n        case \"get\": return FetchMethod.get;\r\n        case \"post\": return FetchMethod.post;\r\n        case \"put\": return FetchMethod.put;\r\n        case \"patch\": return FetchMethod.patch;\r\n        case \"delete\": return FetchMethod.delete;\r\n    }\r\n}\r\nclass FetchRequest {\r\n    constructor(delegate, method, location, body = new URLSearchParams, target = null) {\r\n        this.abortController = new AbortController;\r\n        this.resolveRequestPromise = (value) => { };\r\n        this.delegate = delegate;\r\n        this.method = method;\r\n        this.headers = this.defaultHeaders;\r\n        this.body = body;\r\n        this.url = location;\r\n        this.target = target;\r\n    }\r\n    get location() {\r\n        return this.url;\r\n    }\r\n    get params() {\r\n        return this.url.searchParams;\r\n    }\r\n    get entries() {\r\n        return this.body ? Array.from(this.body.entries()) : [];\r\n    }\r\n    cancel() {\r\n        this.abortController.abort();\r\n    }\r\n    async perform() {\r\n        var _a, _b;\r\n        const { fetchOptions } = this;\r\n        (_b = (_a = this.delegate).prepareHeadersForRequest) === null || _b === void 0 ? void 0 : _b.call(_a, this.headers, this);\r\n        await this.allowRequestToBeIntercepted(fetchOptions);\r\n        try {\r\n            this.delegate.requestStarted(this);\r\n            const response = await fetch(this.url.href, fetchOptions);\r\n            return await this.receive(response);\r\n        }\r\n        catch (error) {\r\n            if (error.name !== 'AbortError') {\r\n                this.delegate.requestErrored(this, error);\r\n                throw error;\r\n            }\r\n        }\r\n        finally {\r\n            this.delegate.requestFinished(this);\r\n        }\r\n    }\r\n    async receive(response) {\r\n        const fetchResponse = new FetchResponse(response);\r\n        const event = dispatch(\"turbo:before-fetch-response\", { cancelable: true, detail: { fetchResponse }, target: this.target });\r\n        if (event.defaultPrevented) {\r\n            this.delegate.requestPreventedHandlingResponse(this, fetchResponse);\r\n        }\r\n        else if (fetchResponse.succeeded) {\r\n            this.delegate.requestSucceededWithResponse(this, fetchResponse);\r\n        }\r\n        else {\r\n            this.delegate.requestFailedWithResponse(this, fetchResponse);\r\n        }\r\n        return fetchResponse;\r\n    }\r\n    get fetchOptions() {\r\n        var _a;\r\n        return {\r\n            method: FetchMethod[this.method].toUpperCase(),\r\n            credentials: \"same-origin\",\r\n            headers: this.headers,\r\n            redirect: \"follow\",\r\n            body: this.isIdempotent ? null : this.body,\r\n            signal: this.abortSignal,\r\n            referrer: (_a = this.delegate.referrer) === null || _a === void 0 ? void 0 : _a.href\r\n        };\r\n    }\r\n    get defaultHeaders() {\r\n        return {\r\n            \"Accept\": \"text/html, application/xhtml+xml\"\r\n        };\r\n    }\r\n    get isIdempotent() {\r\n        return this.method == FetchMethod.get;\r\n    }\r\n    get abortSignal() {\r\n        return this.abortController.signal;\r\n    }\r\n    async allowRequestToBeIntercepted(fetchOptions) {\r\n        const requestInterception = new Promise(resolve => this.resolveRequestPromise = resolve);\r\n        const event = dispatch(\"turbo:before-fetch-request\", {\r\n            cancelable: true,\r\n            detail: {\r\n                fetchOptions,\r\n                url: this.url,\r\n                resume: this.resolveRequestPromise\r\n            },\r\n            target: this.target\r\n        });\r\n        if (event.defaultPrevented)\r\n            await requestInterception;\r\n    }\r\n}\r\n\r\nclass AppearanceObserver {\r\n    constructor(delegate, element) {\r\n        this.started = false;\r\n        this.intersect = entries => {\r\n            const lastEntry = entries.slice(-1)[0];\r\n            if (lastEntry === null || lastEntry === void 0 ? void 0 : lastEntry.isIntersecting) {\r\n                this.delegate.elementAppearedInViewport(this.element);\r\n            }\r\n        };\r\n        this.delegate = delegate;\r\n        this.element = element;\r\n        this.intersectionObserver = new IntersectionObserver(this.intersect);\r\n    }\r\n    start() {\r\n        if (!this.started) {\r\n            this.started = true;\r\n            this.intersectionObserver.observe(this.element);\r\n        }\r\n    }\r\n    stop() {\r\n        if (this.started) {\r\n            this.started = false;\r\n            this.intersectionObserver.unobserve(this.element);\r\n        }\r\n    }\r\n}\r\n\r\nclass StreamMessage {\r\n    constructor(html) {\r\n        this.templateElement = document.createElement(\"template\");\r\n        this.templateElement.innerHTML = html;\r\n    }\r\n    static wrap(message) {\r\n        if (typeof message == \"string\") {\r\n            return new this(message);\r\n        }\r\n        else {\r\n            return message;\r\n        }\r\n    }\r\n    get fragment() {\r\n        const fragment = document.createDocumentFragment();\r\n        for (const element of this.foreignElements) {\r\n            fragment.appendChild(document.importNode(element, true));\r\n        }\r\n        return fragment;\r\n    }\r\n    get foreignElements() {\r\n        return this.templateChildren.reduce((streamElements, child) => {\r\n            if (child.tagName.toLowerCase() == \"turbo-stream\") {\r\n                return [...streamElements, child];\r\n            }\r\n            else {\r\n                return streamElements;\r\n            }\r\n        }, []);\r\n    }\r\n    get templateChildren() {\r\n        return Array.from(this.templateElement.content.children);\r\n    }\r\n}\r\nStreamMessage.contentType = \"text/vnd.turbo-stream.html\";\r\n\r\nvar FormSubmissionState;\r\n(function (FormSubmissionState) {\r\n    FormSubmissionState[FormSubmissionState[\"initialized\"] = 0] = \"initialized\";\r\n    FormSubmissionState[FormSubmissionState[\"requesting\"] = 1] = \"requesting\";\r\n    FormSubmissionState[FormSubmissionState[\"waiting\"] = 2] = \"waiting\";\r\n    FormSubmissionState[FormSubmissionState[\"receiving\"] = 3] = \"receiving\";\r\n    FormSubmissionState[FormSubmissionState[\"stopping\"] = 4] = \"stopping\";\r\n    FormSubmissionState[FormSubmissionState[\"stopped\"] = 5] = \"stopped\";\r\n})(FormSubmissionState || (FormSubmissionState = {}));\r\nvar FormEnctype;\r\n(function (FormEnctype) {\r\n    FormEnctype[\"urlEncoded\"] = \"application/x-www-form-urlencoded\";\r\n    FormEnctype[\"multipart\"] = \"multipart/form-data\";\r\n    FormEnctype[\"plain\"] = \"text/plain\";\r\n})(FormEnctype || (FormEnctype = {}));\r\nfunction formEnctypeFromString(encoding) {\r\n    switch (encoding.toLowerCase()) {\r\n        case FormEnctype.multipart: return FormEnctype.multipart;\r\n        case FormEnctype.plain: return FormEnctype.plain;\r\n        default: return FormEnctype.urlEncoded;\r\n    }\r\n}\r\nclass FormSubmission {\r\n    constructor(delegate, formElement, submitter, mustRedirect = false) {\r\n        this.state = FormSubmissionState.initialized;\r\n        this.delegate = delegate;\r\n        this.formElement = formElement;\r\n        this.submitter = submitter;\r\n        this.formData = buildFormData(formElement, submitter);\r\n        this.location = expandURL(this.action);\r\n        if (this.method == FetchMethod.get) {\r\n            mergeFormDataEntries(this.location, [...this.body.entries()]);\r\n        }\r\n        this.fetchRequest = new FetchRequest(this, this.method, this.location, this.body, this.formElement);\r\n        this.mustRedirect = mustRedirect;\r\n    }\r\n    static confirmMethod(message, element) {\r\n        return confirm(message);\r\n    }\r\n    get method() {\r\n        var _a;\r\n        const method = ((_a = this.submitter) === null || _a === void 0 ? void 0 : _a.getAttribute(\"formmethod\")) || this.formElement.getAttribute(\"method\") || \"\";\r\n        return fetchMethodFromString(method.toLowerCase()) || FetchMethod.get;\r\n    }\r\n    get action() {\r\n        var _a;\r\n        const formElementAction = typeof this.formElement.action === 'string' ? this.formElement.action : null;\r\n        return ((_a = this.submitter) === null || _a === void 0 ? void 0 : _a.getAttribute(\"formaction\")) || this.formElement.getAttribute(\"action\") || formElementAction || \"\";\r\n    }\r\n    get body() {\r\n        if (this.enctype == FormEnctype.urlEncoded || this.method == FetchMethod.get) {\r\n            return new URLSearchParams(this.stringFormData);\r\n        }\r\n        else {\r\n            return this.formData;\r\n        }\r\n    }\r\n    get enctype() {\r\n        var _a;\r\n        return formEnctypeFromString(((_a = this.submitter) === null || _a === void 0 ? void 0 : _a.getAttribute(\"formenctype\")) || this.formElement.enctype);\r\n    }\r\n    get isIdempotent() {\r\n        return this.fetchRequest.isIdempotent;\r\n    }\r\n    get stringFormData() {\r\n        return [...this.formData].reduce((entries, [name, value]) => {\r\n            return entries.concat(typeof value == \"string\" ? [[name, value]] : []);\r\n        }, []);\r\n    }\r\n    get confirmationMessage() {\r\n        return this.formElement.getAttribute(\"data-turbo-confirm\");\r\n    }\r\n    get needsConfirmation() {\r\n        return this.confirmationMessage !== null;\r\n    }\r\n    async start() {\r\n        const { initialized, requesting } = FormSubmissionState;\r\n        if (this.needsConfirmation) {\r\n            const answer = FormSubmission.confirmMethod(this.confirmationMessage, this.formElement);\r\n            if (!answer) {\r\n                return;\r\n            }\r\n        }\r\n        if (this.state == initialized) {\r\n            this.state = requesting;\r\n            return this.fetchRequest.perform();\r\n        }\r\n    }\r\n    stop() {\r\n        const { stopping, stopped } = FormSubmissionState;\r\n        if (this.state != stopping && this.state != stopped) {\r\n            this.state = stopping;\r\n            this.fetchRequest.cancel();\r\n            return true;\r\n        }\r\n    }\r\n    prepareHeadersForRequest(headers, request) {\r\n        if (!request.isIdempotent) {\r\n            const token = getCookieValue(getMetaContent(\"csrf-param\")) || getMetaContent(\"csrf-token\");\r\n            if (token) {\r\n                headers[\"X-CSRF-Token\"] = token;\r\n            }\r\n            headers[\"Accept\"] = [StreamMessage.contentType, headers[\"Accept\"]].join(\", \");\r\n        }\r\n    }\r\n    requestStarted(request) {\r\n        var _a;\r\n        this.state = FormSubmissionState.waiting;\r\n        (_a = this.submitter) === null || _a === void 0 ? void 0 : _a.setAttribute(\"disabled\", \"\");\r\n        dispatch(\"turbo:submit-start\", { target: this.formElement, detail: { formSubmission: this } });\r\n        this.delegate.formSubmissionStarted(this);\r\n    }\r\n    requestPreventedHandlingResponse(request, response) {\r\n        this.result = { success: response.succeeded, fetchResponse: response };\r\n    }\r\n    requestSucceededWithResponse(request, response) {\r\n        if (response.clientError || response.serverError) {\r\n            this.delegate.formSubmissionFailedWithResponse(this, response);\r\n        }\r\n        else if (this.requestMustRedirect(request) && responseSucceededWithoutRedirect(response)) {\r\n            const error = new Error(\"Form responses must redirect to another location\");\r\n            this.delegate.formSubmissionErrored(this, error);\r\n        }\r\n        else {\r\n            this.state = FormSubmissionState.receiving;\r\n            this.result = { success: true, fetchResponse: response };\r\n            this.delegate.formSubmissionSucceededWithResponse(this, response);\r\n        }\r\n    }\r\n    requestFailedWithResponse(request, response) {\r\n        this.result = { success: false, fetchResponse: response };\r\n        this.delegate.formSubmissionFailedWithResponse(this, response);\r\n    }\r\n    requestErrored(request, error) {\r\n        this.result = { success: false, error };\r\n        this.delegate.formSubmissionErrored(this, error);\r\n    }\r\n    requestFinished(request) {\r\n        var _a;\r\n        this.state = FormSubmissionState.stopped;\r\n        (_a = this.submitter) === null || _a === void 0 ? void 0 : _a.removeAttribute(\"disabled\");\r\n        dispatch(\"turbo:submit-end\", { target: this.formElement, detail: Object.assign({ formSubmission: this }, this.result) });\r\n        this.delegate.formSubmissionFinished(this);\r\n    }\r\n    requestMustRedirect(request) {\r\n        return !request.isIdempotent && this.mustRedirect;\r\n    }\r\n}\r\nfunction buildFormData(formElement, submitter) {\r\n    const formData = new FormData(formElement);\r\n    const name = submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute(\"name\");\r\n    const value = submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute(\"value\");\r\n    if (name && value != null && formData.get(name) != value) {\r\n        formData.append(name, value);\r\n    }\r\n    return formData;\r\n}\r\nfunction getCookieValue(cookieName) {\r\n    if (cookieName != null) {\r\n        const cookies = document.cookie ? document.cookie.split(\"; \") : [];\r\n        const cookie = cookies.find((cookie) => cookie.startsWith(cookieName));\r\n        if (cookie) {\r\n            const value = cookie.split(\"=\").slice(1).join(\"=\");\r\n            return value ? decodeURIComponent(value) : undefined;\r\n        }\r\n    }\r\n}\r\nfunction getMetaContent(name) {\r\n    const element = document.querySelector(`meta[name=\"${name}\"]`);\r\n    return element && element.content;\r\n}\r\nfunction responseSucceededWithoutRedirect(response) {\r\n    return response.statusCode == 200 && !response.redirected;\r\n}\r\nfunction mergeFormDataEntries(url, entries) {\r\n    const searchParams = new URLSearchParams;\r\n    for (const [name, value] of entries) {\r\n        if (value instanceof File)\r\n            continue;\r\n        searchParams.append(name, value);\r\n    }\r\n    url.search = searchParams.toString();\r\n    return url;\r\n}\r\n\r\nclass Snapshot {\r\n    constructor(element) {\r\n        this.element = element;\r\n    }\r\n    get children() {\r\n        return [...this.element.children];\r\n    }\r\n    hasAnchor(anchor) {\r\n        return this.getElementForAnchor(anchor) != null;\r\n    }\r\n    getElementForAnchor(anchor) {\r\n        return anchor ? this.element.querySelector(`[id='${anchor}'], a[name='${anchor}']`) : null;\r\n    }\r\n    get isConnected() {\r\n        return this.element.isConnected;\r\n    }\r\n    get firstAutofocusableElement() {\r\n        return this.element.querySelector(\"[autofocus]\");\r\n    }\r\n    get permanentElements() {\r\n        return [...this.element.querySelectorAll(\"[id][data-turbo-permanent]\")];\r\n    }\r\n    getPermanentElementById(id) {\r\n        return this.element.querySelector(`#${id}[data-turbo-permanent]`);\r\n    }\r\n    getPermanentElementMapForSnapshot(snapshot) {\r\n        const permanentElementMap = {};\r\n        for (const currentPermanentElement of this.permanentElements) {\r\n            const { id } = currentPermanentElement;\r\n            const newPermanentElement = snapshot.getPermanentElementById(id);\r\n            if (newPermanentElement) {\r\n                permanentElementMap[id] = [currentPermanentElement, newPermanentElement];\r\n            }\r\n        }\r\n        return permanentElementMap;\r\n    }\r\n}\r\n\r\nclass FormInterceptor {\r\n    constructor(delegate, element) {\r\n        this.submitBubbled = ((event) => {\r\n            const form = event.target;\r\n            if (!event.defaultPrevented && form instanceof HTMLFormElement && form.closest(\"turbo-frame, html\") == this.element) {\r\n                const submitter = event.submitter || undefined;\r\n                const method = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute(\"formmethod\")) || form.method;\r\n                if (method != \"dialog\" && this.delegate.shouldInterceptFormSubmission(form, submitter)) {\r\n                    event.preventDefault();\r\n                    event.stopImmediatePropagation();\r\n                    this.delegate.formSubmissionIntercepted(form, submitter);\r\n                }\r\n            }\r\n        });\r\n        this.delegate = delegate;\r\n        this.element = element;\r\n    }\r\n    start() {\r\n        this.element.addEventListener(\"submit\", this.submitBubbled);\r\n    }\r\n    stop() {\r\n        this.element.removeEventListener(\"submit\", this.submitBubbled);\r\n    }\r\n}\r\n\r\nclass View {\r\n    constructor(delegate, element) {\r\n        this.resolveRenderPromise = (value) => { };\r\n        this.resolveInterceptionPromise = (value) => { };\r\n        this.delegate = delegate;\r\n        this.element = element;\r\n    }\r\n    scrollToAnchor(anchor) {\r\n        const element = this.snapshot.getElementForAnchor(anchor);\r\n        if (element) {\r\n            this.scrollToElement(element);\r\n            this.focusElement(element);\r\n        }\r\n        else {\r\n            this.scrollToPosition({ x: 0, y: 0 });\r\n        }\r\n    }\r\n    scrollToAnchorFromLocation(location) {\r\n        this.scrollToAnchor(getAnchor(location));\r\n    }\r\n    scrollToElement(element) {\r\n        element.scrollIntoView();\r\n    }\r\n    focusElement(element) {\r\n        if (element instanceof HTMLElement) {\r\n            if (element.hasAttribute(\"tabindex\")) {\r\n                element.focus();\r\n            }\r\n            else {\r\n                element.setAttribute(\"tabindex\", \"-1\");\r\n                element.focus();\r\n                element.removeAttribute(\"tabindex\");\r\n            }\r\n        }\r\n    }\r\n    scrollToPosition({ x, y }) {\r\n        this.scrollRoot.scrollTo(x, y);\r\n    }\r\n    scrollToTop() {\r\n        this.scrollToPosition({ x: 0, y: 0 });\r\n    }\r\n    get scrollRoot() {\r\n        return window;\r\n    }\r\n    async render(renderer) {\r\n        const { isPreview, shouldRender, newSnapshot: snapshot } = renderer;\r\n        if (shouldRender) {\r\n            try {\r\n                this.renderPromise = new Promise(resolve => this.resolveRenderPromise = resolve);\r\n                this.renderer = renderer;\r\n                this.prepareToRenderSnapshot(renderer);\r\n                const renderInterception = new Promise(resolve => this.resolveInterceptionPromise = resolve);\r\n                const immediateRender = this.delegate.allowsImmediateRender(snapshot, this.resolveInterceptionPromise);\r\n                if (!immediateRender)\r\n                    await renderInterception;\r\n                await this.renderSnapshot(renderer);\r\n                this.delegate.viewRenderedSnapshot(snapshot, isPreview);\r\n                this.finishRenderingSnapshot(renderer);\r\n            }\r\n            finally {\r\n                delete this.renderer;\r\n                this.resolveRenderPromise(undefined);\r\n                delete this.renderPromise;\r\n            }\r\n        }\r\n        else {\r\n            this.invalidate();\r\n        }\r\n    }\r\n    invalidate() {\r\n        this.delegate.viewInvalidated();\r\n    }\r\n    prepareToRenderSnapshot(renderer) {\r\n        this.markAsPreview(renderer.isPreview);\r\n        renderer.prepareToRender();\r\n    }\r\n    markAsPreview(isPreview) {\r\n        if (isPreview) {\r\n            this.element.setAttribute(\"data-turbo-preview\", \"\");\r\n        }\r\n        else {\r\n            this.element.removeAttribute(\"data-turbo-preview\");\r\n        }\r\n    }\r\n    async renderSnapshot(renderer) {\r\n        await renderer.render();\r\n    }\r\n    finishRenderingSnapshot(renderer) {\r\n        renderer.finishRendering();\r\n    }\r\n}\r\n\r\nclass FrameView extends View {\r\n    invalidate() {\r\n        this.element.innerHTML = \"\";\r\n    }\r\n    get snapshot() {\r\n        return new Snapshot(this.element);\r\n    }\r\n}\r\n\r\nclass LinkInterceptor {\r\n    constructor(delegate, element) {\r\n        this.clickBubbled = (event) => {\r\n            if (this.respondsToEventTarget(event.target)) {\r\n                this.clickEvent = event;\r\n            }\r\n            else {\r\n                delete this.clickEvent;\r\n            }\r\n        };\r\n        this.linkClicked = ((event) => {\r\n            if (this.clickEvent && this.respondsToEventTarget(event.target) && event.target instanceof Element) {\r\n                if (this.delegate.shouldInterceptLinkClick(event.target, event.detail.url)) {\r\n                    this.clickEvent.preventDefault();\r\n                    event.preventDefault();\r\n                    this.delegate.linkClickIntercepted(event.target, event.detail.url);\r\n                }\r\n            }\r\n            delete this.clickEvent;\r\n        });\r\n        this.willVisit = () => {\r\n            delete this.clickEvent;\r\n        };\r\n        this.delegate = delegate;\r\n        this.element = element;\r\n    }\r\n    start() {\r\n        this.element.addEventListener(\"click\", this.clickBubbled);\r\n        document.addEventListener(\"turbo:click\", this.linkClicked);\r\n        document.addEventListener(\"turbo:before-visit\", this.willVisit);\r\n    }\r\n    stop() {\r\n        this.element.removeEventListener(\"click\", this.clickBubbled);\r\n        document.removeEventListener(\"turbo:click\", this.linkClicked);\r\n        document.removeEventListener(\"turbo:before-visit\", this.willVisit);\r\n    }\r\n    respondsToEventTarget(target) {\r\n        const element = target instanceof Element\r\n            ? target\r\n            : target instanceof Node\r\n                ? target.parentElement\r\n                : null;\r\n        return element && element.closest(\"turbo-frame, html\") == this.element;\r\n    }\r\n}\r\n\r\nclass Bardo {\r\n    constructor(permanentElementMap) {\r\n        this.permanentElementMap = permanentElementMap;\r\n    }\r\n    static preservingPermanentElements(permanentElementMap, callback) {\r\n        const bardo = new this(permanentElementMap);\r\n        bardo.enter();\r\n        callback();\r\n        bardo.leave();\r\n    }\r\n    enter() {\r\n        for (const id in this.permanentElementMap) {\r\n            const [, newPermanentElement] = this.permanentElementMap[id];\r\n            this.replaceNewPermanentElementWithPlaceholder(newPermanentElement);\r\n        }\r\n    }\r\n    leave() {\r\n        for (const id in this.permanentElementMap) {\r\n            const [currentPermanentElement] = this.permanentElementMap[id];\r\n            this.replaceCurrentPermanentElementWithClone(currentPermanentElement);\r\n            this.replacePlaceholderWithPermanentElement(currentPermanentElement);\r\n        }\r\n    }\r\n    replaceNewPermanentElementWithPlaceholder(permanentElement) {\r\n        const placeholder = createPlaceholderForPermanentElement(permanentElement);\r\n        permanentElement.replaceWith(placeholder);\r\n    }\r\n    replaceCurrentPermanentElementWithClone(permanentElement) {\r\n        const clone = permanentElement.cloneNode(true);\r\n        permanentElement.replaceWith(clone);\r\n    }\r\n    replacePlaceholderWithPermanentElement(permanentElement) {\r\n        const placeholder = this.getPlaceholderById(permanentElement.id);\r\n        placeholder === null || placeholder === void 0 ? void 0 : placeholder.replaceWith(permanentElement);\r\n    }\r\n    getPlaceholderById(id) {\r\n        return this.placeholders.find(element => element.content == id);\r\n    }\r\n    get placeholders() {\r\n        return [...document.querySelectorAll(\"meta[name=turbo-permanent-placeholder][content]\")];\r\n    }\r\n}\r\nfunction createPlaceholderForPermanentElement(permanentElement) {\r\n    const element = document.createElement(\"meta\");\r\n    element.setAttribute(\"name\", \"turbo-permanent-placeholder\");\r\n    element.setAttribute(\"content\", permanentElement.id);\r\n    return element;\r\n}\r\n\r\nclass Renderer {\r\n    constructor(currentSnapshot, newSnapshot, isPreview, willRender = true) {\r\n        this.currentSnapshot = currentSnapshot;\r\n        this.newSnapshot = newSnapshot;\r\n        this.isPreview = isPreview;\r\n        this.willRender = willRender;\r\n        this.promise = new Promise((resolve, reject) => this.resolvingFunctions = { resolve, reject });\r\n    }\r\n    get shouldRender() {\r\n        return true;\r\n    }\r\n    prepareToRender() {\r\n        return;\r\n    }\r\n    finishRendering() {\r\n        if (this.resolvingFunctions) {\r\n            this.resolvingFunctions.resolve();\r\n            delete this.resolvingFunctions;\r\n        }\r\n    }\r\n    createScriptElement(element) {\r\n        if (element.getAttribute(\"data-turbo-eval\") == \"false\") {\r\n            return element;\r\n        }\r\n        else {\r\n            const createdScriptElement = document.createElement(\"script\");\r\n            if (this.cspNonce) {\r\n                createdScriptElement.nonce = this.cspNonce;\r\n            }\r\n            createdScriptElement.textContent = element.textContent;\r\n            createdScriptElement.async = false;\r\n            copyElementAttributes(createdScriptElement, element);\r\n            return createdScriptElement;\r\n        }\r\n    }\r\n    preservingPermanentElements(callback) {\r\n        Bardo.preservingPermanentElements(this.permanentElementMap, callback);\r\n    }\r\n    focusFirstAutofocusableElement() {\r\n        const element = this.connectedSnapshot.firstAutofocusableElement;\r\n        if (elementIsFocusable(element)) {\r\n            element.focus();\r\n        }\r\n    }\r\n    get connectedSnapshot() {\r\n        return this.newSnapshot.isConnected ? this.newSnapshot : this.currentSnapshot;\r\n    }\r\n    get currentElement() {\r\n        return this.currentSnapshot.element;\r\n    }\r\n    get newElement() {\r\n        return this.newSnapshot.element;\r\n    }\r\n    get permanentElementMap() {\r\n        return this.currentSnapshot.getPermanentElementMapForSnapshot(this.newSnapshot);\r\n    }\r\n    get cspNonce() {\r\n        var _a;\r\n        return (_a = document.head.querySelector('meta[name=\"csp-nonce\"]')) === null || _a === void 0 ? void 0 : _a.getAttribute(\"content\");\r\n    }\r\n}\r\nfunction copyElementAttributes(destinationElement, sourceElement) {\r\n    for (const { name, value } of [...sourceElement.attributes]) {\r\n        destinationElement.setAttribute(name, value);\r\n    }\r\n}\r\nfunction elementIsFocusable(element) {\r\n    return element && typeof element.focus == \"function\";\r\n}\r\n\r\nclass FrameRenderer extends Renderer {\r\n    get shouldRender() {\r\n        return true;\r\n    }\r\n    async render() {\r\n        await nextAnimationFrame();\r\n        this.preservingPermanentElements(() => {\r\n            this.loadFrameElement();\r\n        });\r\n        this.scrollFrameIntoView();\r\n        await nextAnimationFrame();\r\n        this.focusFirstAutofocusableElement();\r\n        await nextAnimationFrame();\r\n        this.activateScriptElements();\r\n    }\r\n    loadFrameElement() {\r\n        var _a;\r\n        const destinationRange = document.createRange();\r\n        destinationRange.selectNodeContents(this.currentElement);\r\n        destinationRange.deleteContents();\r\n        const frameElement = this.newElement;\r\n        const sourceRange = (_a = frameElement.ownerDocument) === null || _a === void 0 ? void 0 : _a.createRange();\r\n        if (sourceRange) {\r\n            sourceRange.selectNodeContents(frameElement);\r\n            this.currentElement.appendChild(sourceRange.extractContents());\r\n        }\r\n    }\r\n    scrollFrameIntoView() {\r\n        if (this.currentElement.autoscroll || this.newElement.autoscroll) {\r\n            const element = this.currentElement.firstElementChild;\r\n            const block = readScrollLogicalPosition(this.currentElement.getAttribute(\"data-autoscroll-block\"), \"end\");\r\n            if (element) {\r\n                element.scrollIntoView({ block });\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    activateScriptElements() {\r\n        for (const inertScriptElement of this.newScriptElements) {\r\n            const activatedScriptElement = this.createScriptElement(inertScriptElement);\r\n            inertScriptElement.replaceWith(activatedScriptElement);\r\n        }\r\n    }\r\n    get newScriptElements() {\r\n        return this.currentElement.querySelectorAll(\"script\");\r\n    }\r\n}\r\nfunction readScrollLogicalPosition(value, defaultValue) {\r\n    if (value == \"end\" || value == \"start\" || value == \"center\" || value == \"nearest\") {\r\n        return value;\r\n    }\r\n    else {\r\n        return defaultValue;\r\n    }\r\n}\r\n\r\nclass ProgressBar {\r\n    constructor() {\r\n        this.hiding = false;\r\n        this.value = 0;\r\n        this.visible = false;\r\n        this.trickle = () => {\r\n            this.setValue(this.value + Math.random() / 100);\r\n        };\r\n        this.stylesheetElement = this.createStylesheetElement();\r\n        this.progressElement = this.createProgressElement();\r\n        this.installStylesheetElement();\r\n        this.setValue(0);\r\n    }\r\n    static get defaultCSS() {\r\n        return unindent `\r\n      .turbo-progress-bar {\r\n        position: fixed;\r\n        display: block;\r\n        top: 0;\r\n        left: 0;\r\n        height: 3px;\r\n        background: #0076ff;\r\n        z-index: 9999;\r\n        transition:\r\n          width ${ProgressBar.animationDuration}ms ease-out,\r\n          opacity ${ProgressBar.animationDuration / 2}ms ${ProgressBar.animationDuration / 2}ms ease-in;\r\n        transform: translate3d(0, 0, 0);\r\n      }\r\n    `;\r\n    }\r\n    show() {\r\n        if (!this.visible) {\r\n            this.visible = true;\r\n            this.installProgressElement();\r\n            this.startTrickling();\r\n        }\r\n    }\r\n    hide() {\r\n        if (this.visible && !this.hiding) {\r\n            this.hiding = true;\r\n            this.fadeProgressElement(() => {\r\n                this.uninstallProgressElement();\r\n                this.stopTrickling();\r\n                this.visible = false;\r\n                this.hiding = false;\r\n            });\r\n        }\r\n    }\r\n    setValue(value) {\r\n        this.value = value;\r\n        this.refresh();\r\n    }\r\n    installStylesheetElement() {\r\n        document.head.insertBefore(this.stylesheetElement, document.head.firstChild);\r\n    }\r\n    installProgressElement() {\r\n        this.progressElement.style.width = \"0\";\r\n        this.progressElement.style.opacity = \"1\";\r\n        document.documentElement.insertBefore(this.progressElement, document.body);\r\n        this.refresh();\r\n    }\r\n    fadeProgressElement(callback) {\r\n        this.progressElement.style.opacity = \"0\";\r\n        setTimeout(callback, ProgressBar.animationDuration * 1.5);\r\n    }\r\n    uninstallProgressElement() {\r\n        if (this.progressElement.parentNode) {\r\n            document.documentElement.removeChild(this.progressElement);\r\n        }\r\n    }\r\n    startTrickling() {\r\n        if (!this.trickleInterval) {\r\n            this.trickleInterval = window.setInterval(this.trickle, ProgressBar.animationDuration);\r\n        }\r\n    }\r\n    stopTrickling() {\r\n        window.clearInterval(this.trickleInterval);\r\n        delete this.trickleInterval;\r\n    }\r\n    refresh() {\r\n        requestAnimationFrame(() => {\r\n            this.progressElement.style.width = `${10 + (this.value * 90)}%`;\r\n        });\r\n    }\r\n    createStylesheetElement() {\r\n        const element = document.createElement(\"style\");\r\n        element.type = \"text/css\";\r\n        element.textContent = ProgressBar.defaultCSS;\r\n        return element;\r\n    }\r\n    createProgressElement() {\r\n        const element = document.createElement(\"div\");\r\n        element.className = \"turbo-progress-bar\";\r\n        return element;\r\n    }\r\n}\r\nProgressBar.animationDuration = 300;\r\n\r\nclass HeadSnapshot extends Snapshot {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.detailsByOuterHTML = this.children\r\n            .filter((element) => !elementIsNoscript(element))\r\n            .map((element) => elementWithoutNonce(element))\r\n            .reduce((result, element) => {\r\n            const { outerHTML } = element;\r\n            const details = outerHTML in result\r\n                ? result[outerHTML]\r\n                : {\r\n                    type: elementType(element),\r\n                    tracked: elementIsTracked(element),\r\n                    elements: []\r\n                };\r\n            return Object.assign(Object.assign({}, result), { [outerHTML]: Object.assign(Object.assign({}, details), { elements: [...details.elements, element] }) });\r\n        }, {});\r\n    }\r\n    get trackedElementSignature() {\r\n        return Object.keys(this.detailsByOuterHTML)\r\n            .filter(outerHTML => this.detailsByOuterHTML[outerHTML].tracked)\r\n            .join(\"\");\r\n    }\r\n    getScriptElementsNotInSnapshot(snapshot) {\r\n        return this.getElementsMatchingTypeNotInSnapshot(\"script\", snapshot);\r\n    }\r\n    getStylesheetElementsNotInSnapshot(snapshot) {\r\n        return this.getElementsMatchingTypeNotInSnapshot(\"stylesheet\", snapshot);\r\n    }\r\n    getElementsMatchingTypeNotInSnapshot(matchedType, snapshot) {\r\n        return Object.keys(this.detailsByOuterHTML)\r\n            .filter(outerHTML => !(outerHTML in snapshot.detailsByOuterHTML))\r\n            .map(outerHTML => this.detailsByOuterHTML[outerHTML])\r\n            .filter(({ type }) => type == matchedType)\r\n            .map(({ elements: [element] }) => element);\r\n    }\r\n    get provisionalElements() {\r\n        return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {\r\n            const { type, tracked, elements } = this.detailsByOuterHTML[outerHTML];\r\n            if (type == null && !tracked) {\r\n                return [...result, ...elements];\r\n            }\r\n            else if (elements.length > 1) {\r\n                return [...result, ...elements.slice(1)];\r\n            }\r\n            else {\r\n                return result;\r\n            }\r\n        }, []);\r\n    }\r\n    getMetaValue(name) {\r\n        const element = this.findMetaElementByName(name);\r\n        return element\r\n            ? element.getAttribute(\"content\")\r\n            : null;\r\n    }\r\n    findMetaElementByName(name) {\r\n        return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {\r\n            const { elements: [element] } = this.detailsByOuterHTML[outerHTML];\r\n            return elementIsMetaElementWithName(element, name) ? element : result;\r\n        }, undefined);\r\n    }\r\n}\r\nfunction elementType(element) {\r\n    if (elementIsScript(element)) {\r\n        return \"script\";\r\n    }\r\n    else if (elementIsStylesheet(element)) {\r\n        return \"stylesheet\";\r\n    }\r\n}\r\nfunction elementIsTracked(element) {\r\n    return element.getAttribute(\"data-turbo-track\") == \"reload\";\r\n}\r\nfunction elementIsScript(element) {\r\n    const tagName = element.tagName.toLowerCase();\r\n    return tagName == \"script\";\r\n}\r\nfunction elementIsNoscript(element) {\r\n    const tagName = element.tagName.toLowerCase();\r\n    return tagName == \"noscript\";\r\n}\r\nfunction elementIsStylesheet(element) {\r\n    const tagName = element.tagName.toLowerCase();\r\n    return tagName == \"style\" || (tagName == \"link\" && element.getAttribute(\"rel\") == \"stylesheet\");\r\n}\r\nfunction elementIsMetaElementWithName(element, name) {\r\n    const tagName = element.tagName.toLowerCase();\r\n    return tagName == \"meta\" && element.getAttribute(\"name\") == name;\r\n}\r\nfunction elementWithoutNonce(element) {\r\n    if (element.hasAttribute(\"nonce\")) {\r\n        element.setAttribute(\"nonce\", \"\");\r\n    }\r\n    return element;\r\n}\r\n\r\nclass PageSnapshot extends Snapshot {\r\n    constructor(element, headSnapshot) {\r\n        super(element);\r\n        this.headSnapshot = headSnapshot;\r\n    }\r\n    static fromHTMLString(html = \"\") {\r\n        return this.fromDocument(parseHTMLDocument(html));\r\n    }\r\n    static fromElement(element) {\r\n        return this.fromDocument(element.ownerDocument);\r\n    }\r\n    static fromDocument({ head, body }) {\r\n        return new this(body, new HeadSnapshot(head));\r\n    }\r\n    clone() {\r\n        return new PageSnapshot(this.element.cloneNode(true), this.headSnapshot);\r\n    }\r\n    get headElement() {\r\n        return this.headSnapshot.element;\r\n    }\r\n    get rootLocation() {\r\n        var _a;\r\n        const root = (_a = this.getSetting(\"root\")) !== null && _a !== void 0 ? _a : \"/\";\r\n        return expandURL(root);\r\n    }\r\n    get cacheControlValue() {\r\n        return this.getSetting(\"cache-control\");\r\n    }\r\n    get isPreviewable() {\r\n        return this.cacheControlValue != \"no-preview\";\r\n    }\r\n    get isCacheable() {\r\n        return this.cacheControlValue != \"no-cache\";\r\n    }\r\n    get isVisitable() {\r\n        return this.getSetting(\"visit-control\") != \"reload\";\r\n    }\r\n    getSetting(name) {\r\n        return this.headSnapshot.getMetaValue(`turbo-${name}`);\r\n    }\r\n}\r\n\r\nvar TimingMetric;\r\n(function (TimingMetric) {\r\n    TimingMetric[\"visitStart\"] = \"visitStart\";\r\n    TimingMetric[\"requestStart\"] = \"requestStart\";\r\n    TimingMetric[\"requestEnd\"] = \"requestEnd\";\r\n    TimingMetric[\"visitEnd\"] = \"visitEnd\";\r\n})(TimingMetric || (TimingMetric = {}));\r\nvar VisitState;\r\n(function (VisitState) {\r\n    VisitState[\"initialized\"] = \"initialized\";\r\n    VisitState[\"started\"] = \"started\";\r\n    VisitState[\"canceled\"] = \"canceled\";\r\n    VisitState[\"failed\"] = \"failed\";\r\n    VisitState[\"completed\"] = \"completed\";\r\n})(VisitState || (VisitState = {}));\r\nconst defaultOptions = {\r\n    action: \"advance\",\r\n    historyChanged: false,\r\n    visitCachedSnapshot: () => { },\r\n    willRender: true,\r\n};\r\nvar SystemStatusCode;\r\n(function (SystemStatusCode) {\r\n    SystemStatusCode[SystemStatusCode[\"networkFailure\"] = 0] = \"networkFailure\";\r\n    SystemStatusCode[SystemStatusCode[\"timeoutFailure\"] = -1] = \"timeoutFailure\";\r\n    SystemStatusCode[SystemStatusCode[\"contentTypeMismatch\"] = -2] = \"contentTypeMismatch\";\r\n})(SystemStatusCode || (SystemStatusCode = {}));\r\nclass Visit {\r\n    constructor(delegate, location, restorationIdentifier, options = {}) {\r\n        this.identifier = uuid();\r\n        this.timingMetrics = {};\r\n        this.followedRedirect = false;\r\n        this.historyChanged = false;\r\n        this.scrolled = false;\r\n        this.snapshotCached = false;\r\n        this.state = VisitState.initialized;\r\n        this.delegate = delegate;\r\n        this.location = location;\r\n        this.restorationIdentifier = restorationIdentifier || uuid();\r\n        const { action, historyChanged, referrer, snapshotHTML, response, visitCachedSnapshot, willRender } = Object.assign(Object.assign({}, defaultOptions), options);\r\n        this.action = action;\r\n        this.historyChanged = historyChanged;\r\n        this.referrer = referrer;\r\n        this.snapshotHTML = snapshotHTML;\r\n        this.response = response;\r\n        this.isSamePage = this.delegate.locationWithActionIsSamePage(this.location, this.action);\r\n        this.visitCachedSnapshot = visitCachedSnapshot;\r\n        this.willRender = willRender;\r\n        this.scrolled = !willRender;\r\n    }\r\n    get adapter() {\r\n        return this.delegate.adapter;\r\n    }\r\n    get view() {\r\n        return this.delegate.view;\r\n    }\r\n    get history() {\r\n        return this.delegate.history;\r\n    }\r\n    get restorationData() {\r\n        return this.history.getRestorationDataForIdentifier(this.restorationIdentifier);\r\n    }\r\n    get silent() {\r\n        return this.isSamePage;\r\n    }\r\n    start() {\r\n        if (this.state == VisitState.initialized) {\r\n            this.recordTimingMetric(TimingMetric.visitStart);\r\n            this.state = VisitState.started;\r\n            this.adapter.visitStarted(this);\r\n            this.delegate.visitStarted(this);\r\n        }\r\n    }\r\n    cancel() {\r\n        if (this.state == VisitState.started) {\r\n            if (this.request) {\r\n                this.request.cancel();\r\n            }\r\n            this.cancelRender();\r\n            this.state = VisitState.canceled;\r\n        }\r\n    }\r\n    complete() {\r\n        if (this.state == VisitState.started) {\r\n            this.recordTimingMetric(TimingMetric.visitEnd);\r\n            this.state = VisitState.completed;\r\n            this.adapter.visitCompleted(this);\r\n            this.delegate.visitCompleted(this);\r\n            this.followRedirect();\r\n        }\r\n    }\r\n    fail() {\r\n        if (this.state == VisitState.started) {\r\n            this.state = VisitState.failed;\r\n            this.adapter.visitFailed(this);\r\n        }\r\n    }\r\n    changeHistory() {\r\n        var _a;\r\n        if (!this.historyChanged) {\r\n            const actionForHistory = this.location.href === ((_a = this.referrer) === null || _a === void 0 ? void 0 : _a.href) ? \"replace\" : this.action;\r\n            const method = this.getHistoryMethodForAction(actionForHistory);\r\n            this.history.update(method, this.location, this.restorationIdentifier);\r\n            this.historyChanged = true;\r\n        }\r\n    }\r\n    issueRequest() {\r\n        if (this.hasPreloadedResponse()) {\r\n            this.simulateRequest();\r\n        }\r\n        else if (this.shouldIssueRequest() && !this.request) {\r\n            this.request = new FetchRequest(this, FetchMethod.get, this.location);\r\n            this.request.perform();\r\n        }\r\n    }\r\n    simulateRequest() {\r\n        if (this.response) {\r\n            this.startRequest();\r\n            this.recordResponse();\r\n            this.finishRequest();\r\n        }\r\n    }\r\n    startRequest() {\r\n        this.recordTimingMetric(TimingMetric.requestStart);\r\n        this.adapter.visitRequestStarted(this);\r\n    }\r\n    recordResponse(response = this.response) {\r\n        this.response = response;\r\n        if (response) {\r\n            const { statusCode } = response;\r\n            if (isSuccessful(statusCode)) {\r\n                this.adapter.visitRequestCompleted(this);\r\n            }\r\n            else {\r\n                this.adapter.visitRequestFailedWithStatusCode(this, statusCode);\r\n            }\r\n        }\r\n    }\r\n    finishRequest() {\r\n        this.recordTimingMetric(TimingMetric.requestEnd);\r\n        this.adapter.visitRequestFinished(this);\r\n    }\r\n    loadResponse() {\r\n        if (this.response) {\r\n            const { statusCode, responseHTML } = this.response;\r\n            this.render(async () => {\r\n                this.cacheSnapshot();\r\n                if (this.view.renderPromise)\r\n                    await this.view.renderPromise;\r\n                if (isSuccessful(statusCode) && responseHTML != null) {\r\n                    await this.view.renderPage(PageSnapshot.fromHTMLString(responseHTML), false, this.willRender);\r\n                    this.adapter.visitRendered(this);\r\n                    this.complete();\r\n                }\r\n                else {\r\n                    await this.view.renderError(PageSnapshot.fromHTMLString(responseHTML));\r\n                    this.adapter.visitRendered(this);\r\n                    this.fail();\r\n                }\r\n            });\r\n        }\r\n    }\r\n    getCachedSnapshot() {\r\n        const snapshot = this.view.getCachedSnapshotForLocation(this.location) || this.getPreloadedSnapshot();\r\n        if (snapshot && (!getAnchor(this.location) || snapshot.hasAnchor(getAnchor(this.location)))) {\r\n            if (this.action == \"restore\" || snapshot.isPreviewable) {\r\n                return snapshot;\r\n            }\r\n        }\r\n    }\r\n    getPreloadedSnapshot() {\r\n        if (this.snapshotHTML) {\r\n            return PageSnapshot.fromHTMLString(this.snapshotHTML);\r\n        }\r\n    }\r\n    hasCachedSnapshot() {\r\n        return this.getCachedSnapshot() != null;\r\n    }\r\n    loadCachedSnapshot() {\r\n        const snapshot = this.getCachedSnapshot();\r\n        if (snapshot) {\r\n            const isPreview = this.shouldIssueRequest();\r\n            this.render(async () => {\r\n                this.cacheSnapshot();\r\n                if (this.isSamePage) {\r\n                    this.adapter.visitRendered(this);\r\n                }\r\n                else {\r\n                    if (this.view.renderPromise)\r\n                        await this.view.renderPromise;\r\n                    await this.view.renderPage(snapshot, isPreview, this.willRender);\r\n                    this.adapter.visitRendered(this);\r\n                    if (!isPreview) {\r\n                        this.complete();\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n    followRedirect() {\r\n        var _a;\r\n        if (this.redirectedToLocation && !this.followedRedirect && ((_a = this.response) === null || _a === void 0 ? void 0 : _a.redirected)) {\r\n            this.adapter.visitProposedToLocation(this.redirectedToLocation, {\r\n                action: 'replace',\r\n                response: this.response\r\n            });\r\n            this.followedRedirect = true;\r\n        }\r\n    }\r\n    goToSamePageAnchor() {\r\n        if (this.isSamePage) {\r\n            this.render(async () => {\r\n                this.cacheSnapshot();\r\n                this.adapter.visitRendered(this);\r\n            });\r\n        }\r\n    }\r\n    requestStarted() {\r\n        this.startRequest();\r\n    }\r\n    requestPreventedHandlingResponse(request, response) {\r\n    }\r\n    async requestSucceededWithResponse(request, response) {\r\n        const responseHTML = await response.responseHTML;\r\n        const { redirected, statusCode } = response;\r\n        if (responseHTML == undefined) {\r\n            this.recordResponse({ statusCode: SystemStatusCode.contentTypeMismatch, redirected });\r\n        }\r\n        else {\r\n            this.redirectedToLocation = response.redirected ? response.location : undefined;\r\n            this.recordResponse({ statusCode: statusCode, responseHTML, redirected });\r\n        }\r\n    }\r\n    async requestFailedWithResponse(request, response) {\r\n        const responseHTML = await response.responseHTML;\r\n        const { redirected, statusCode } = response;\r\n        if (responseHTML == undefined) {\r\n            this.recordResponse({ statusCode: SystemStatusCode.contentTypeMismatch, redirected });\r\n        }\r\n        else {\r\n            this.recordResponse({ statusCode: statusCode, responseHTML, redirected });\r\n        }\r\n    }\r\n    requestErrored(request, error) {\r\n        this.recordResponse({ statusCode: SystemStatusCode.networkFailure, redirected: false });\r\n    }\r\n    requestFinished() {\r\n        this.finishRequest();\r\n    }\r\n    performScroll() {\r\n        if (!this.scrolled) {\r\n            if (this.action == \"restore\") {\r\n                this.scrollToRestoredPosition() || this.scrollToAnchor() || this.view.scrollToTop();\r\n            }\r\n            else {\r\n                this.scrollToAnchor() || this.view.scrollToTop();\r\n            }\r\n            if (this.isSamePage) {\r\n                this.delegate.visitScrolledToSamePageLocation(this.view.lastRenderedLocation, this.location);\r\n            }\r\n            this.scrolled = true;\r\n        }\r\n    }\r\n    scrollToRestoredPosition() {\r\n        const { scrollPosition } = this.restorationData;\r\n        if (scrollPosition) {\r\n            this.view.scrollToPosition(scrollPosition);\r\n            return true;\r\n        }\r\n    }\r\n    scrollToAnchor() {\r\n        const anchor = getAnchor(this.location);\r\n        if (anchor != null) {\r\n            this.view.scrollToAnchor(anchor);\r\n            return true;\r\n        }\r\n    }\r\n    recordTimingMetric(metric) {\r\n        this.timingMetrics[metric] = new Date().getTime();\r\n    }\r\n    getTimingMetrics() {\r\n        return Object.assign({}, this.timingMetrics);\r\n    }\r\n    getHistoryMethodForAction(action) {\r\n        switch (action) {\r\n            case \"replace\": return history.replaceState;\r\n            case \"advance\":\r\n            case \"restore\": return history.pushState;\r\n        }\r\n    }\r\n    hasPreloadedResponse() {\r\n        return typeof this.response == \"object\";\r\n    }\r\n    shouldIssueRequest() {\r\n        if (this.isSamePage) {\r\n            return false;\r\n        }\r\n        else if (this.action == \"restore\") {\r\n            return !this.hasCachedSnapshot();\r\n        }\r\n        else {\r\n            return this.willRender;\r\n        }\r\n    }\r\n    cacheSnapshot() {\r\n        if (!this.snapshotCached) {\r\n            this.view.cacheSnapshot().then(snapshot => snapshot && this.visitCachedSnapshot(snapshot));\r\n            this.snapshotCached = true;\r\n        }\r\n    }\r\n    async render(callback) {\r\n        this.cancelRender();\r\n        await new Promise(resolve => {\r\n            this.frame = requestAnimationFrame(() => resolve());\r\n        });\r\n        await callback();\r\n        delete this.frame;\r\n        this.performScroll();\r\n    }\r\n    cancelRender() {\r\n        if (this.frame) {\r\n            cancelAnimationFrame(this.frame);\r\n            delete this.frame;\r\n        }\r\n    }\r\n}\r\nfunction isSuccessful(statusCode) {\r\n    return statusCode >= 200 && statusCode < 300;\r\n}\r\n\r\nclass BrowserAdapter {\r\n    constructor(session) {\r\n        this.progressBar = new ProgressBar;\r\n        this.showProgressBar = () => {\r\n            this.progressBar.show();\r\n        };\r\n        this.session = session;\r\n    }\r\n    visitProposedToLocation(location, options) {\r\n        this.navigator.startVisit(location, uuid(), options);\r\n    }\r\n    visitStarted(visit) {\r\n        visit.loadCachedSnapshot();\r\n        visit.issueRequest();\r\n        visit.changeHistory();\r\n        visit.goToSamePageAnchor();\r\n    }\r\n    visitRequestStarted(visit) {\r\n        this.progressBar.setValue(0);\r\n        if (visit.hasCachedSnapshot() || visit.action != \"restore\") {\r\n            this.showVisitProgressBarAfterDelay();\r\n        }\r\n        else {\r\n            this.showProgressBar();\r\n        }\r\n    }\r\n    visitRequestCompleted(visit) {\r\n        visit.loadResponse();\r\n    }\r\n    visitRequestFailedWithStatusCode(visit, statusCode) {\r\n        switch (statusCode) {\r\n            case SystemStatusCode.networkFailure:\r\n            case SystemStatusCode.timeoutFailure:\r\n            case SystemStatusCode.contentTypeMismatch:\r\n                return this.reload();\r\n            default:\r\n                return visit.loadResponse();\r\n        }\r\n    }\r\n    visitRequestFinished(visit) {\r\n        this.progressBar.setValue(1);\r\n        this.hideVisitProgressBar();\r\n    }\r\n    visitCompleted(visit) {\r\n    }\r\n    pageInvalidated() {\r\n        this.reload();\r\n    }\r\n    visitFailed(visit) {\r\n    }\r\n    visitRendered(visit) {\r\n    }\r\n    formSubmissionStarted(formSubmission) {\r\n        this.progressBar.setValue(0);\r\n        this.showFormProgressBarAfterDelay();\r\n    }\r\n    formSubmissionFinished(formSubmission) {\r\n        this.progressBar.setValue(1);\r\n        this.hideFormProgressBar();\r\n    }\r\n    showVisitProgressBarAfterDelay() {\r\n        this.visitProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);\r\n    }\r\n    hideVisitProgressBar() {\r\n        this.progressBar.hide();\r\n        if (this.visitProgressBarTimeout != null) {\r\n            window.clearTimeout(this.visitProgressBarTimeout);\r\n            delete this.visitProgressBarTimeout;\r\n        }\r\n    }\r\n    showFormProgressBarAfterDelay() {\r\n        if (this.formProgressBarTimeout == null) {\r\n            this.formProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);\r\n        }\r\n    }\r\n    hideFormProgressBar() {\r\n        this.progressBar.hide();\r\n        if (this.formProgressBarTimeout != null) {\r\n            window.clearTimeout(this.formProgressBarTimeout);\r\n            delete this.formProgressBarTimeout;\r\n        }\r\n    }\r\n    reload() {\r\n        window.location.reload();\r\n    }\r\n    get navigator() {\r\n        return this.session.navigator;\r\n    }\r\n}\r\n\r\nclass CacheObserver {\r\n    constructor() {\r\n        this.started = false;\r\n    }\r\n    start() {\r\n        if (!this.started) {\r\n            this.started = true;\r\n            addEventListener(\"turbo:before-cache\", this.removeStaleElements, false);\r\n        }\r\n    }\r\n    stop() {\r\n        if (this.started) {\r\n            this.started = false;\r\n            removeEventListener(\"turbo:before-cache\", this.removeStaleElements, false);\r\n        }\r\n    }\r\n    removeStaleElements() {\r\n        const staleElements = [...document.querySelectorAll('[data-turbo-cache=\"false\"]')];\r\n        for (const element of staleElements) {\r\n            element.remove();\r\n        }\r\n    }\r\n}\r\n\r\nclass FormSubmitObserver {\r\n    constructor(delegate) {\r\n        this.started = false;\r\n        this.submitCaptured = () => {\r\n            removeEventListener(\"submit\", this.submitBubbled, false);\r\n            addEventListener(\"submit\", this.submitBubbled, false);\r\n        };\r\n        this.submitBubbled = ((event) => {\r\n            if (!event.defaultPrevented) {\r\n                const form = event.target instanceof HTMLFormElement ? event.target : undefined;\r\n                const submitter = event.submitter || undefined;\r\n                if (form) {\r\n                    const method = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute(\"formmethod\")) || form.getAttribute(\"method\");\r\n                    if (method != \"dialog\" && this.delegate.willSubmitForm(form, submitter)) {\r\n                        event.preventDefault();\r\n                        this.delegate.formSubmitted(form, submitter);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        this.delegate = delegate;\r\n    }\r\n    start() {\r\n        if (!this.started) {\r\n            addEventListener(\"submit\", this.submitCaptured, true);\r\n            this.started = true;\r\n        }\r\n    }\r\n    stop() {\r\n        if (this.started) {\r\n            removeEventListener(\"submit\", this.submitCaptured, true);\r\n            this.started = false;\r\n        }\r\n    }\r\n}\r\n\r\nclass FrameRedirector {\r\n    constructor(element) {\r\n        this.element = element;\r\n        this.linkInterceptor = new LinkInterceptor(this, element);\r\n        this.formInterceptor = new FormInterceptor(this, element);\r\n    }\r\n    start() {\r\n        this.linkInterceptor.start();\r\n        this.formInterceptor.start();\r\n    }\r\n    stop() {\r\n        this.linkInterceptor.stop();\r\n        this.formInterceptor.stop();\r\n    }\r\n    shouldInterceptLinkClick(element, url) {\r\n        return this.shouldRedirect(element);\r\n    }\r\n    linkClickIntercepted(element, url) {\r\n        const frame = this.findFrameElement(element);\r\n        if (frame) {\r\n            frame.delegate.linkClickIntercepted(element, url);\r\n        }\r\n    }\r\n    shouldInterceptFormSubmission(element, submitter) {\r\n        return this.shouldSubmit(element, submitter);\r\n    }\r\n    formSubmissionIntercepted(element, submitter) {\r\n        const frame = this.findFrameElement(element, submitter);\r\n        if (frame) {\r\n            frame.removeAttribute(\"reloadable\");\r\n            frame.delegate.formSubmissionIntercepted(element, submitter);\r\n        }\r\n    }\r\n    shouldSubmit(form, submitter) {\r\n        var _a;\r\n        const action = getAction(form, submitter);\r\n        const meta = this.element.ownerDocument.querySelector(`meta[name=\"turbo-root\"]`);\r\n        const rootLocation = expandURL((_a = meta === null || meta === void 0 ? void 0 : meta.content) !== null && _a !== void 0 ? _a : \"/\");\r\n        return this.shouldRedirect(form, submitter) && locationIsVisitable(action, rootLocation);\r\n    }\r\n    shouldRedirect(element, submitter) {\r\n        const frame = this.findFrameElement(element, submitter);\r\n        return frame ? frame != element.closest(\"turbo-frame\") : false;\r\n    }\r\n    findFrameElement(element, submitter) {\r\n        const id = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute(\"data-turbo-frame\")) || element.getAttribute(\"data-turbo-frame\");\r\n        if (id && id != \"_top\") {\r\n            const frame = this.element.querySelector(`#${id}:not([disabled])`);\r\n            if (frame instanceof FrameElement) {\r\n                return frame;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nclass History {\r\n    constructor(delegate) {\r\n        this.restorationIdentifier = uuid();\r\n        this.restorationData = {};\r\n        this.started = false;\r\n        this.pageLoaded = false;\r\n        this.onPopState = (event) => {\r\n            if (this.shouldHandlePopState()) {\r\n                const { turbo } = event.state || {};\r\n                if (turbo) {\r\n                    this.location = new URL(window.location.href);\r\n                    const { restorationIdentifier } = turbo;\r\n                    this.restorationIdentifier = restorationIdentifier;\r\n                    this.delegate.historyPoppedToLocationWithRestorationIdentifier(this.location, restorationIdentifier);\r\n                }\r\n            }\r\n        };\r\n        this.onPageLoad = async (event) => {\r\n            await nextMicrotask();\r\n            this.pageLoaded = true;\r\n        };\r\n        this.delegate = delegate;\r\n    }\r\n    start() {\r\n        if (!this.started) {\r\n            addEventListener(\"popstate\", this.onPopState, false);\r\n            addEventListener(\"load\", this.onPageLoad, false);\r\n            this.started = true;\r\n            this.replace(new URL(window.location.href));\r\n        }\r\n    }\r\n    stop() {\r\n        if (this.started) {\r\n            removeEventListener(\"popstate\", this.onPopState, false);\r\n            removeEventListener(\"load\", this.onPageLoad, false);\r\n            this.started = false;\r\n        }\r\n    }\r\n    push(location, restorationIdentifier) {\r\n        this.update(history.pushState, location, restorationIdentifier);\r\n    }\r\n    replace(location, restorationIdentifier) {\r\n        this.update(history.replaceState, location, restorationIdentifier);\r\n    }\r\n    update(method, location, restorationIdentifier = uuid()) {\r\n        const state = { turbo: { restorationIdentifier } };\r\n        method.call(history, state, \"\", location.href);\r\n        this.location = location;\r\n        this.restorationIdentifier = restorationIdentifier;\r\n    }\r\n    getRestorationDataForIdentifier(restorationIdentifier) {\r\n        return this.restorationData[restorationIdentifier] || {};\r\n    }\r\n    updateRestorationData(additionalData) {\r\n        const { restorationIdentifier } = this;\r\n        const restorationData = this.restorationData[restorationIdentifier];\r\n        this.restorationData[restorationIdentifier] = Object.assign(Object.assign({}, restorationData), additionalData);\r\n    }\r\n    assumeControlOfScrollRestoration() {\r\n        var _a;\r\n        if (!this.previousScrollRestoration) {\r\n            this.previousScrollRestoration = (_a = history.scrollRestoration) !== null && _a !== void 0 ? _a : \"auto\";\r\n            history.scrollRestoration = \"manual\";\r\n        }\r\n    }\r\n    relinquishControlOfScrollRestoration() {\r\n        if (this.previousScrollRestoration) {\r\n            history.scrollRestoration = this.previousScrollRestoration;\r\n            delete this.previousScrollRestoration;\r\n        }\r\n    }\r\n    shouldHandlePopState() {\r\n        return this.pageIsLoaded();\r\n    }\r\n    pageIsLoaded() {\r\n        return this.pageLoaded || document.readyState == \"complete\";\r\n    }\r\n}\r\n\r\nclass LinkClickObserver {\r\n    constructor(delegate) {\r\n        this.started = false;\r\n        this.clickCaptured = () => {\r\n            removeEventListener(\"click\", this.clickBubbled, false);\r\n            addEventListener(\"click\", this.clickBubbled, false);\r\n        };\r\n        this.clickBubbled = (event) => {\r\n            if (this.clickEventIsSignificant(event)) {\r\n                const target = (event.composedPath && event.composedPath()[0]) || event.target;\r\n                const link = this.findLinkFromClickTarget(target);\r\n                if (link) {\r\n                    const location = this.getLocationForLink(link);\r\n                    if (this.delegate.willFollowLinkToLocation(link, location)) {\r\n                        event.preventDefault();\r\n                        this.delegate.followedLinkToLocation(link, location);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        this.delegate = delegate;\r\n    }\r\n    start() {\r\n        if (!this.started) {\r\n            addEventListener(\"click\", this.clickCaptured, true);\r\n            this.started = true;\r\n        }\r\n    }\r\n    stop() {\r\n        if (this.started) {\r\n            removeEventListener(\"click\", this.clickCaptured, true);\r\n            this.started = false;\r\n        }\r\n    }\r\n    clickEventIsSignificant(event) {\r\n        return !((event.target && event.target.isContentEditable)\r\n            || event.defaultPrevented\r\n            || event.which > 1\r\n            || event.altKey\r\n            || event.ctrlKey\r\n            || event.metaKey\r\n            || event.shiftKey);\r\n    }\r\n    findLinkFromClickTarget(target) {\r\n        if (target instanceof Element) {\r\n            return target.closest(\"a[href]:not([target^=_]):not([download])\");\r\n        }\r\n    }\r\n    getLocationForLink(link) {\r\n        return expandURL(link.getAttribute(\"href\") || \"\");\r\n    }\r\n}\r\n\r\nfunction isAction(action) {\r\n    return action == \"advance\" || action == \"replace\" || action == \"restore\";\r\n}\r\n\r\nclass Navigator {\r\n    constructor(delegate) {\r\n        this.delegate = delegate;\r\n    }\r\n    proposeVisit(location, options = {}) {\r\n        if (this.delegate.allowsVisitingLocationWithAction(location, options.action)) {\r\n            if (locationIsVisitable(location, this.view.snapshot.rootLocation)) {\r\n                this.delegate.visitProposedToLocation(location, options);\r\n            }\r\n            else {\r\n                window.location.href = location.toString();\r\n            }\r\n        }\r\n    }\r\n    startVisit(locatable, restorationIdentifier, options = {}) {\r\n        this.stop();\r\n        this.currentVisit = new Visit(this, expandURL(locatable), restorationIdentifier, Object.assign({ referrer: this.location }, options));\r\n        this.currentVisit.start();\r\n    }\r\n    submitForm(form, submitter) {\r\n        this.stop();\r\n        this.formSubmission = new FormSubmission(this, form, submitter, true);\r\n        this.formSubmission.start();\r\n    }\r\n    stop() {\r\n        if (this.formSubmission) {\r\n            this.formSubmission.stop();\r\n            delete this.formSubmission;\r\n        }\r\n        if (this.currentVisit) {\r\n            this.currentVisit.cancel();\r\n            delete this.currentVisit;\r\n        }\r\n    }\r\n    get adapter() {\r\n        return this.delegate.adapter;\r\n    }\r\n    get view() {\r\n        return this.delegate.view;\r\n    }\r\n    get history() {\r\n        return this.delegate.history;\r\n    }\r\n    formSubmissionStarted(formSubmission) {\r\n        if (typeof this.adapter.formSubmissionStarted === 'function') {\r\n            this.adapter.formSubmissionStarted(formSubmission);\r\n        }\r\n    }\r\n    async formSubmissionSucceededWithResponse(formSubmission, fetchResponse) {\r\n        if (formSubmission == this.formSubmission) {\r\n            const responseHTML = await fetchResponse.responseHTML;\r\n            if (responseHTML) {\r\n                if (formSubmission.method != FetchMethod.get) {\r\n                    this.view.clearSnapshotCache();\r\n                }\r\n                const { statusCode, redirected } = fetchResponse;\r\n                const action = this.getActionForFormSubmission(formSubmission);\r\n                const visitOptions = { action, response: { statusCode, responseHTML, redirected } };\r\n                this.proposeVisit(fetchResponse.location, visitOptions);\r\n            }\r\n        }\r\n    }\r\n    async formSubmissionFailedWithResponse(formSubmission, fetchResponse) {\r\n        const responseHTML = await fetchResponse.responseHTML;\r\n        if (responseHTML) {\r\n            const snapshot = PageSnapshot.fromHTMLString(responseHTML);\r\n            if (fetchResponse.serverError) {\r\n                await this.view.renderError(snapshot);\r\n            }\r\n            else {\r\n                await this.view.renderPage(snapshot);\r\n            }\r\n            this.view.scrollToTop();\r\n            this.view.clearSnapshotCache();\r\n        }\r\n    }\r\n    formSubmissionErrored(formSubmission, error) {\r\n        console.error(error);\r\n    }\r\n    formSubmissionFinished(formSubmission) {\r\n        if (typeof this.adapter.formSubmissionFinished === 'function') {\r\n            this.adapter.formSubmissionFinished(formSubmission);\r\n        }\r\n    }\r\n    visitStarted(visit) {\r\n        this.delegate.visitStarted(visit);\r\n    }\r\n    visitCompleted(visit) {\r\n        this.delegate.visitCompleted(visit);\r\n    }\r\n    locationWithActionIsSamePage(location, action) {\r\n        const anchor = getAnchor(location);\r\n        const currentAnchor = getAnchor(this.view.lastRenderedLocation);\r\n        const isRestorationToTop = action === 'restore' && typeof anchor === 'undefined';\r\n        return action !== \"replace\" &&\r\n            getRequestURL(location) === getRequestURL(this.view.lastRenderedLocation) &&\r\n            (isRestorationToTop || (anchor != null && anchor !== currentAnchor));\r\n    }\r\n    visitScrolledToSamePageLocation(oldURL, newURL) {\r\n        this.delegate.visitScrolledToSamePageLocation(oldURL, newURL);\r\n    }\r\n    get location() {\r\n        return this.history.location;\r\n    }\r\n    get restorationIdentifier() {\r\n        return this.history.restorationIdentifier;\r\n    }\r\n    getActionForFormSubmission(formSubmission) {\r\n        const { formElement, submitter } = formSubmission;\r\n        const action = getAttribute(\"data-turbo-action\", submitter, formElement);\r\n        return isAction(action) ? action : \"advance\";\r\n    }\r\n}\r\n\r\nvar PageStage;\r\n(function (PageStage) {\r\n    PageStage[PageStage[\"initial\"] = 0] = \"initial\";\r\n    PageStage[PageStage[\"loading\"] = 1] = \"loading\";\r\n    PageStage[PageStage[\"interactive\"] = 2] = \"interactive\";\r\n    PageStage[PageStage[\"complete\"] = 3] = \"complete\";\r\n})(PageStage || (PageStage = {}));\r\nclass PageObserver {\r\n    constructor(delegate) {\r\n        this.stage = PageStage.initial;\r\n        this.started = false;\r\n        this.interpretReadyState = () => {\r\n            const { readyState } = this;\r\n            if (readyState == \"interactive\") {\r\n                this.pageIsInteractive();\r\n            }\r\n            else if (readyState == \"complete\") {\r\n                this.pageIsComplete();\r\n            }\r\n        };\r\n        this.pageWillUnload = () => {\r\n            this.delegate.pageWillUnload();\r\n        };\r\n        this.delegate = delegate;\r\n    }\r\n    start() {\r\n        if (!this.started) {\r\n            if (this.stage == PageStage.initial) {\r\n                this.stage = PageStage.loading;\r\n            }\r\n            document.addEventListener(\"readystatechange\", this.interpretReadyState, false);\r\n            addEventListener(\"pagehide\", this.pageWillUnload, false);\r\n            this.started = true;\r\n        }\r\n    }\r\n    stop() {\r\n        if (this.started) {\r\n            document.removeEventListener(\"readystatechange\", this.interpretReadyState, false);\r\n            removeEventListener(\"pagehide\", this.pageWillUnload, false);\r\n            this.started = false;\r\n        }\r\n    }\r\n    pageIsInteractive() {\r\n        if (this.stage == PageStage.loading) {\r\n            this.stage = PageStage.interactive;\r\n            this.delegate.pageBecameInteractive();\r\n        }\r\n    }\r\n    pageIsComplete() {\r\n        this.pageIsInteractive();\r\n        if (this.stage == PageStage.interactive) {\r\n            this.stage = PageStage.complete;\r\n            this.delegate.pageLoaded();\r\n        }\r\n    }\r\n    get readyState() {\r\n        return document.readyState;\r\n    }\r\n}\r\n\r\nclass ScrollObserver {\r\n    constructor(delegate) {\r\n        this.started = false;\r\n        this.onScroll = () => {\r\n            this.updatePosition({ x: window.pageXOffset, y: window.pageYOffset });\r\n        };\r\n        this.delegate = delegate;\r\n    }\r\n    start() {\r\n        if (!this.started) {\r\n            addEventListener(\"scroll\", this.onScroll, false);\r\n            this.onScroll();\r\n            this.started = true;\r\n        }\r\n    }\r\n    stop() {\r\n        if (this.started) {\r\n            removeEventListener(\"scroll\", this.onScroll, false);\r\n            this.started = false;\r\n        }\r\n    }\r\n    updatePosition(position) {\r\n        this.delegate.scrollPositionChanged(position);\r\n    }\r\n}\r\n\r\nclass StreamObserver {\r\n    constructor(delegate) {\r\n        this.sources = new Set;\r\n        this.started = false;\r\n        this.inspectFetchResponse = ((event) => {\r\n            const response = fetchResponseFromEvent(event);\r\n            if (response && fetchResponseIsStream(response)) {\r\n                event.preventDefault();\r\n                this.receiveMessageResponse(response);\r\n            }\r\n        });\r\n        this.receiveMessageEvent = (event) => {\r\n            if (this.started && typeof event.data == \"string\") {\r\n                this.receiveMessageHTML(event.data);\r\n            }\r\n        };\r\n        this.delegate = delegate;\r\n    }\r\n    start() {\r\n        if (!this.started) {\r\n            this.started = true;\r\n            addEventListener(\"turbo:before-fetch-response\", this.inspectFetchResponse, false);\r\n        }\r\n    }\r\n    stop() {\r\n        if (this.started) {\r\n            this.started = false;\r\n            removeEventListener(\"turbo:before-fetch-response\", this.inspectFetchResponse, false);\r\n        }\r\n    }\r\n    connectStreamSource(source) {\r\n        if (!this.streamSourceIsConnected(source)) {\r\n            this.sources.add(source);\r\n            source.addEventListener(\"message\", this.receiveMessageEvent, false);\r\n        }\r\n    }\r\n    disconnectStreamSource(source) {\r\n        if (this.streamSourceIsConnected(source)) {\r\n            this.sources.delete(source);\r\n            source.removeEventListener(\"message\", this.receiveMessageEvent, false);\r\n        }\r\n    }\r\n    streamSourceIsConnected(source) {\r\n        return this.sources.has(source);\r\n    }\r\n    async receiveMessageResponse(response) {\r\n        const html = await response.responseHTML;\r\n        if (html) {\r\n            this.receiveMessageHTML(html);\r\n        }\r\n    }\r\n    receiveMessageHTML(html) {\r\n        this.delegate.receivedMessageFromStream(new StreamMessage(html));\r\n    }\r\n}\r\nfunction fetchResponseFromEvent(event) {\r\n    var _a;\r\n    const fetchResponse = (_a = event.detail) === null || _a === void 0 ? void 0 : _a.fetchResponse;\r\n    if (fetchResponse instanceof FetchResponse) {\r\n        return fetchResponse;\r\n    }\r\n}\r\nfunction fetchResponseIsStream(response) {\r\n    var _a;\r\n    const contentType = (_a = response.contentType) !== null && _a !== void 0 ? _a : \"\";\r\n    return contentType.startsWith(StreamMessage.contentType);\r\n}\r\n\r\nclass ErrorRenderer extends Renderer {\r\n    async render() {\r\n        this.replaceHeadAndBody();\r\n        this.activateScriptElements();\r\n    }\r\n    replaceHeadAndBody() {\r\n        const { documentElement, head, body } = document;\r\n        documentElement.replaceChild(this.newHead, head);\r\n        documentElement.replaceChild(this.newElement, body);\r\n    }\r\n    activateScriptElements() {\r\n        for (const replaceableElement of this.scriptElements) {\r\n            const parentNode = replaceableElement.parentNode;\r\n            if (parentNode) {\r\n                const element = this.createScriptElement(replaceableElement);\r\n                parentNode.replaceChild(element, replaceableElement);\r\n            }\r\n        }\r\n    }\r\n    get newHead() {\r\n        return this.newSnapshot.headSnapshot.element;\r\n    }\r\n    get scriptElements() {\r\n        return [...document.documentElement.querySelectorAll(\"script\")];\r\n    }\r\n}\r\n\r\nclass PageRenderer extends Renderer {\r\n    get shouldRender() {\r\n        return this.newSnapshot.isVisitable && this.trackedElementsAreIdentical;\r\n    }\r\n    prepareToRender() {\r\n        this.mergeHead();\r\n    }\r\n    async render() {\r\n        if (this.willRender) {\r\n            this.replaceBody();\r\n        }\r\n    }\r\n    finishRendering() {\r\n        super.finishRendering();\r\n        if (!this.isPreview) {\r\n            this.focusFirstAutofocusableElement();\r\n        }\r\n    }\r\n    get currentHeadSnapshot() {\r\n        return this.currentSnapshot.headSnapshot;\r\n    }\r\n    get newHeadSnapshot() {\r\n        return this.newSnapshot.headSnapshot;\r\n    }\r\n    get newElement() {\r\n        return this.newSnapshot.element;\r\n    }\r\n    mergeHead() {\r\n        this.copyNewHeadStylesheetElements();\r\n        this.copyNewHeadScriptElements();\r\n        this.removeCurrentHeadProvisionalElements();\r\n        this.copyNewHeadProvisionalElements();\r\n    }\r\n    replaceBody() {\r\n        this.preservingPermanentElements(() => {\r\n            this.activateNewBody();\r\n            this.assignNewBody();\r\n        });\r\n    }\r\n    get trackedElementsAreIdentical() {\r\n        return this.currentHeadSnapshot.trackedElementSignature == this.newHeadSnapshot.trackedElementSignature;\r\n    }\r\n    copyNewHeadStylesheetElements() {\r\n        for (const element of this.newHeadStylesheetElements) {\r\n            document.head.appendChild(element);\r\n        }\r\n    }\r\n    copyNewHeadScriptElements() {\r\n        for (const element of this.newHeadScriptElements) {\r\n            document.head.appendChild(this.createScriptElement(element));\r\n        }\r\n    }\r\n    removeCurrentHeadProvisionalElements() {\r\n        for (const element of this.currentHeadProvisionalElements) {\r\n            document.head.removeChild(element);\r\n        }\r\n    }\r\n    copyNewHeadProvisionalElements() {\r\n        for (const element of this.newHeadProvisionalElements) {\r\n            document.head.appendChild(element);\r\n        }\r\n    }\r\n    activateNewBody() {\r\n        document.adoptNode(this.newElement);\r\n        this.activateNewBodyScriptElements();\r\n    }\r\n    activateNewBodyScriptElements() {\r\n        for (const inertScriptElement of this.newBodyScriptElements) {\r\n            const activatedScriptElement = this.createScriptElement(inertScriptElement);\r\n            inertScriptElement.replaceWith(activatedScriptElement);\r\n        }\r\n    }\r\n    assignNewBody() {\r\n        if (document.body && this.newElement instanceof HTMLBodyElement) {\r\n            document.body.replaceWith(this.newElement);\r\n        }\r\n        else {\r\n            document.documentElement.appendChild(this.newElement);\r\n        }\r\n    }\r\n    get newHeadStylesheetElements() {\r\n        return this.newHeadSnapshot.getStylesheetElementsNotInSnapshot(this.currentHeadSnapshot);\r\n    }\r\n    get newHeadScriptElements() {\r\n        return this.newHeadSnapshot.getScriptElementsNotInSnapshot(this.currentHeadSnapshot);\r\n    }\r\n    get currentHeadProvisionalElements() {\r\n        return this.currentHeadSnapshot.provisionalElements;\r\n    }\r\n    get newHeadProvisionalElements() {\r\n        return this.newHeadSnapshot.provisionalElements;\r\n    }\r\n    get newBodyScriptElements() {\r\n        return this.newElement.querySelectorAll(\"script\");\r\n    }\r\n}\r\n\r\nclass SnapshotCache {\r\n    constructor(size) {\r\n        this.keys = [];\r\n        this.snapshots = {};\r\n        this.size = size;\r\n    }\r\n    has(location) {\r\n        return toCacheKey(location) in this.snapshots;\r\n    }\r\n    get(location) {\r\n        if (this.has(location)) {\r\n            const snapshot = this.read(location);\r\n            this.touch(location);\r\n            return snapshot;\r\n        }\r\n    }\r\n    put(location, snapshot) {\r\n        this.write(location, snapshot);\r\n        this.touch(location);\r\n        return snapshot;\r\n    }\r\n    clear() {\r\n        this.snapshots = {};\r\n    }\r\n    read(location) {\r\n        return this.snapshots[toCacheKey(location)];\r\n    }\r\n    write(location, snapshot) {\r\n        this.snapshots[toCacheKey(location)] = snapshot;\r\n    }\r\n    touch(location) {\r\n        const key = toCacheKey(location);\r\n        const index = this.keys.indexOf(key);\r\n        if (index > -1)\r\n            this.keys.splice(index, 1);\r\n        this.keys.unshift(key);\r\n        this.trim();\r\n    }\r\n    trim() {\r\n        for (const key of this.keys.splice(this.size)) {\r\n            delete this.snapshots[key];\r\n        }\r\n    }\r\n}\r\n\r\nclass PageView extends View {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.snapshotCache = new SnapshotCache(10);\r\n        this.lastRenderedLocation = new URL(location.href);\r\n    }\r\n    renderPage(snapshot, isPreview = false, willRender = true) {\r\n        const renderer = new PageRenderer(this.snapshot, snapshot, isPreview, willRender);\r\n        return this.render(renderer);\r\n    }\r\n    renderError(snapshot) {\r\n        const renderer = new ErrorRenderer(this.snapshot, snapshot, false);\r\n        return this.render(renderer);\r\n    }\r\n    clearSnapshotCache() {\r\n        this.snapshotCache.clear();\r\n    }\r\n    async cacheSnapshot() {\r\n        if (this.shouldCacheSnapshot) {\r\n            this.delegate.viewWillCacheSnapshot();\r\n            const { snapshot, lastRenderedLocation: location } = this;\r\n            await nextEventLoopTick();\r\n            const cachedSnapshot = snapshot.clone();\r\n            this.snapshotCache.put(location, cachedSnapshot);\r\n            return cachedSnapshot;\r\n        }\r\n    }\r\n    getCachedSnapshotForLocation(location) {\r\n        return this.snapshotCache.get(location);\r\n    }\r\n    get snapshot() {\r\n        return PageSnapshot.fromElement(this.element);\r\n    }\r\n    get shouldCacheSnapshot() {\r\n        return this.snapshot.isCacheable;\r\n    }\r\n}\r\n\r\nclass Session {\r\n    constructor() {\r\n        this.navigator = new Navigator(this);\r\n        this.history = new History(this);\r\n        this.view = new PageView(this, document.documentElement);\r\n        this.adapter = new BrowserAdapter(this);\r\n        this.pageObserver = new PageObserver(this);\r\n        this.cacheObserver = new CacheObserver();\r\n        this.linkClickObserver = new LinkClickObserver(this);\r\n        this.formSubmitObserver = new FormSubmitObserver(this);\r\n        this.scrollObserver = new ScrollObserver(this);\r\n        this.streamObserver = new StreamObserver(this);\r\n        this.frameRedirector = new FrameRedirector(document.documentElement);\r\n        this.drive = true;\r\n        this.enabled = true;\r\n        this.progressBarDelay = 500;\r\n        this.started = false;\r\n    }\r\n    start() {\r\n        if (!this.started) {\r\n            this.pageObserver.start();\r\n            this.cacheObserver.start();\r\n            this.linkClickObserver.start();\r\n            this.formSubmitObserver.start();\r\n            this.scrollObserver.start();\r\n            this.streamObserver.start();\r\n            this.frameRedirector.start();\r\n            this.history.start();\r\n            this.started = true;\r\n            this.enabled = true;\r\n        }\r\n    }\r\n    disable() {\r\n        this.enabled = false;\r\n    }\r\n    stop() {\r\n        if (this.started) {\r\n            this.pageObserver.stop();\r\n            this.cacheObserver.stop();\r\n            this.linkClickObserver.stop();\r\n            this.formSubmitObserver.stop();\r\n            this.scrollObserver.stop();\r\n            this.streamObserver.stop();\r\n            this.frameRedirector.stop();\r\n            this.history.stop();\r\n            this.started = false;\r\n        }\r\n    }\r\n    registerAdapter(adapter) {\r\n        this.adapter = adapter;\r\n    }\r\n    visit(location, options = {}) {\r\n        this.navigator.proposeVisit(expandURL(location), options);\r\n    }\r\n    connectStreamSource(source) {\r\n        this.streamObserver.connectStreamSource(source);\r\n    }\r\n    disconnectStreamSource(source) {\r\n        this.streamObserver.disconnectStreamSource(source);\r\n    }\r\n    renderStreamMessage(message) {\r\n        document.documentElement.appendChild(StreamMessage.wrap(message).fragment);\r\n    }\r\n    clearCache() {\r\n        this.view.clearSnapshotCache();\r\n    }\r\n    setProgressBarDelay(delay) {\r\n        this.progressBarDelay = delay;\r\n    }\r\n    get location() {\r\n        return this.history.location;\r\n    }\r\n    get restorationIdentifier() {\r\n        return this.history.restorationIdentifier;\r\n    }\r\n    historyPoppedToLocationWithRestorationIdentifier(location, restorationIdentifier) {\r\n        if (this.enabled) {\r\n            this.navigator.startVisit(location, restorationIdentifier, { action: \"restore\", historyChanged: true });\r\n        }\r\n        else {\r\n            this.adapter.pageInvalidated();\r\n        }\r\n    }\r\n    scrollPositionChanged(position) {\r\n        this.history.updateRestorationData({ scrollPosition: position });\r\n    }\r\n    willFollowLinkToLocation(link, location) {\r\n        return this.elementDriveEnabled(link)\r\n            && locationIsVisitable(location, this.snapshot.rootLocation)\r\n            && this.applicationAllowsFollowingLinkToLocation(link, location);\r\n    }\r\n    followedLinkToLocation(link, location) {\r\n        const action = this.getActionForLink(link);\r\n        this.convertLinkWithMethodClickToFormSubmission(link) || this.visit(location.href, { action });\r\n    }\r\n    convertLinkWithMethodClickToFormSubmission(link) {\r\n        const linkMethod = link.getAttribute(\"data-turbo-method\");\r\n        if (linkMethod) {\r\n            const form = document.createElement(\"form\");\r\n            form.method = linkMethod;\r\n            form.action = link.getAttribute(\"href\") || \"undefined\";\r\n            form.hidden = true;\r\n            if (link.hasAttribute(\"data-turbo-confirm\")) {\r\n                form.setAttribute(\"data-turbo-confirm\", link.getAttribute(\"data-turbo-confirm\"));\r\n            }\r\n            const frame = this.getTargetFrameForLink(link);\r\n            if (frame) {\r\n                form.setAttribute(\"data-turbo-frame\", frame);\r\n                form.addEventListener(\"turbo:submit-start\", () => form.remove());\r\n            }\r\n            else {\r\n                form.addEventListener(\"submit\", () => form.remove());\r\n            }\r\n            document.body.appendChild(form);\r\n            return dispatch(\"submit\", { cancelable: true, target: form });\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    allowsVisitingLocationWithAction(location, action) {\r\n        return this.locationWithActionIsSamePage(location, action) || this.applicationAllowsVisitingLocation(location);\r\n    }\r\n    visitProposedToLocation(location, options) {\r\n        extendURLWithDeprecatedProperties(location);\r\n        this.adapter.visitProposedToLocation(location, options);\r\n    }\r\n    visitStarted(visit) {\r\n        extendURLWithDeprecatedProperties(visit.location);\r\n        if (!visit.silent) {\r\n            this.notifyApplicationAfterVisitingLocation(visit.location, visit.action);\r\n        }\r\n    }\r\n    visitCompleted(visit) {\r\n        this.notifyApplicationAfterPageLoad(visit.getTimingMetrics());\r\n    }\r\n    locationWithActionIsSamePage(location, action) {\r\n        return this.navigator.locationWithActionIsSamePage(location, action);\r\n    }\r\n    visitScrolledToSamePageLocation(oldURL, newURL) {\r\n        this.notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL);\r\n    }\r\n    willSubmitForm(form, submitter) {\r\n        const action = getAction(form, submitter);\r\n        return this.elementDriveEnabled(form)\r\n            && (!submitter || this.elementDriveEnabled(submitter))\r\n            && locationIsVisitable(expandURL(action), this.snapshot.rootLocation);\r\n    }\r\n    formSubmitted(form, submitter) {\r\n        this.navigator.submitForm(form, submitter);\r\n    }\r\n    pageBecameInteractive() {\r\n        this.view.lastRenderedLocation = this.location;\r\n        this.notifyApplicationAfterPageLoad();\r\n    }\r\n    pageLoaded() {\r\n        this.history.assumeControlOfScrollRestoration();\r\n    }\r\n    pageWillUnload() {\r\n        this.history.relinquishControlOfScrollRestoration();\r\n    }\r\n    receivedMessageFromStream(message) {\r\n        this.renderStreamMessage(message);\r\n    }\r\n    viewWillCacheSnapshot() {\r\n        var _a;\r\n        if (!((_a = this.navigator.currentVisit) === null || _a === void 0 ? void 0 : _a.silent)) {\r\n            this.notifyApplicationBeforeCachingSnapshot();\r\n        }\r\n    }\r\n    allowsImmediateRender({ element }, resume) {\r\n        const event = this.notifyApplicationBeforeRender(element, resume);\r\n        return !event.defaultPrevented;\r\n    }\r\n    viewRenderedSnapshot(snapshot, isPreview) {\r\n        this.view.lastRenderedLocation = this.history.location;\r\n        this.notifyApplicationAfterRender();\r\n    }\r\n    viewInvalidated() {\r\n        this.adapter.pageInvalidated();\r\n    }\r\n    frameLoaded(frame) {\r\n        this.notifyApplicationAfterFrameLoad(frame);\r\n    }\r\n    frameRendered(fetchResponse, frame) {\r\n        this.notifyApplicationAfterFrameRender(fetchResponse, frame);\r\n    }\r\n    applicationAllowsFollowingLinkToLocation(link, location) {\r\n        const event = this.notifyApplicationAfterClickingLinkToLocation(link, location);\r\n        return !event.defaultPrevented;\r\n    }\r\n    applicationAllowsVisitingLocation(location) {\r\n        const event = this.notifyApplicationBeforeVisitingLocation(location);\r\n        return !event.defaultPrevented;\r\n    }\r\n    notifyApplicationAfterClickingLinkToLocation(link, location) {\r\n        return dispatch(\"turbo:click\", { target: link, detail: { url: location.href }, cancelable: true });\r\n    }\r\n    notifyApplicationBeforeVisitingLocation(location) {\r\n        return dispatch(\"turbo:before-visit\", { detail: { url: location.href }, cancelable: true });\r\n    }\r\n    notifyApplicationAfterVisitingLocation(location, action) {\r\n        markAsBusy(document.documentElement);\r\n        return dispatch(\"turbo:visit\", { detail: { url: location.href, action } });\r\n    }\r\n    notifyApplicationBeforeCachingSnapshot() {\r\n        return dispatch(\"turbo:before-cache\");\r\n    }\r\n    notifyApplicationBeforeRender(newBody, resume) {\r\n        return dispatch(\"turbo:before-render\", { detail: { newBody, resume }, cancelable: true });\r\n    }\r\n    notifyApplicationAfterRender() {\r\n        return dispatch(\"turbo:render\");\r\n    }\r\n    notifyApplicationAfterPageLoad(timing = {}) {\r\n        clearBusyState(document.documentElement);\r\n        return dispatch(\"turbo:load\", { detail: { url: this.location.href, timing } });\r\n    }\r\n    notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL) {\r\n        dispatchEvent(new HashChangeEvent(\"hashchange\", { oldURL: oldURL.toString(), newURL: newURL.toString() }));\r\n    }\r\n    notifyApplicationAfterFrameLoad(frame) {\r\n        return dispatch(\"turbo:frame-load\", { target: frame });\r\n    }\r\n    notifyApplicationAfterFrameRender(fetchResponse, frame) {\r\n        return dispatch(\"turbo:frame-render\", { detail: { fetchResponse }, target: frame, cancelable: true });\r\n    }\r\n    elementDriveEnabled(element) {\r\n        const container = element === null || element === void 0 ? void 0 : element.closest(\"[data-turbo]\");\r\n        if (this.drive) {\r\n            if (container) {\r\n                return container.getAttribute(\"data-turbo\") != \"false\";\r\n            }\r\n            else {\r\n                return true;\r\n            }\r\n        }\r\n        else {\r\n            if (container) {\r\n                return container.getAttribute(\"data-turbo\") == \"true\";\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    getActionForLink(link) {\r\n        const action = link.getAttribute(\"data-turbo-action\");\r\n        return isAction(action) ? action : \"advance\";\r\n    }\r\n    getTargetFrameForLink(link) {\r\n        const frame = link.getAttribute(\"data-turbo-frame\");\r\n        if (frame) {\r\n            return frame;\r\n        }\r\n        else {\r\n            const container = link.closest(\"turbo-frame\");\r\n            if (container) {\r\n                return container.id;\r\n            }\r\n        }\r\n    }\r\n    get snapshot() {\r\n        return this.view.snapshot;\r\n    }\r\n}\r\nfunction extendURLWithDeprecatedProperties(url) {\r\n    Object.defineProperties(url, deprecatedLocationPropertyDescriptors);\r\n}\r\nconst deprecatedLocationPropertyDescriptors = {\r\n    absoluteURL: {\r\n        get() {\r\n            return this.toString();\r\n        }\r\n    }\r\n};\r\n\r\nconst session = new Session;\r\nconst { navigator: navigator$1 } = session;\r\nfunction start() {\r\n    session.start();\r\n}\r\nfunction registerAdapter(adapter) {\r\n    session.registerAdapter(adapter);\r\n}\r\nfunction visit(location, options) {\r\n    session.visit(location, options);\r\n}\r\nfunction connectStreamSource(source) {\r\n    session.connectStreamSource(source);\r\n}\r\nfunction disconnectStreamSource(source) {\r\n    session.disconnectStreamSource(source);\r\n}\r\nfunction renderStreamMessage(message) {\r\n    session.renderStreamMessage(message);\r\n}\r\nfunction clearCache() {\r\n    session.clearCache();\r\n}\r\nfunction setProgressBarDelay(delay) {\r\n    session.setProgressBarDelay(delay);\r\n}\r\nfunction setConfirmMethod(confirmMethod) {\r\n    FormSubmission.confirmMethod = confirmMethod;\r\n}\r\n\r\nvar Turbo = /*#__PURE__*/Object.freeze({\r\n    __proto__: null,\r\n    navigator: navigator$1,\r\n    session: session,\r\n    PageRenderer: PageRenderer,\r\n    PageSnapshot: PageSnapshot,\r\n    start: start,\r\n    registerAdapter: registerAdapter,\r\n    visit: visit,\r\n    connectStreamSource: connectStreamSource,\r\n    disconnectStreamSource: disconnectStreamSource,\r\n    renderStreamMessage: renderStreamMessage,\r\n    clearCache: clearCache,\r\n    setProgressBarDelay: setProgressBarDelay,\r\n    setConfirmMethod: setConfirmMethod\r\n});\r\n\r\nclass FrameController {\r\n    constructor(element) {\r\n        this.fetchResponseLoaded = (fetchResponse) => { };\r\n        this.currentFetchRequest = null;\r\n        this.resolveVisitPromise = () => { };\r\n        this.connected = false;\r\n        this.hasBeenLoaded = false;\r\n        this.settingSourceURL = false;\r\n        this.element = element;\r\n        this.view = new FrameView(this, this.element);\r\n        this.appearanceObserver = new AppearanceObserver(this, this.element);\r\n        this.linkInterceptor = new LinkInterceptor(this, this.element);\r\n        this.formInterceptor = new FormInterceptor(this, this.element);\r\n    }\r\n    connect() {\r\n        if (!this.connected) {\r\n            this.connected = true;\r\n            this.reloadable = false;\r\n            if (this.loadingStyle == FrameLoadingStyle.lazy) {\r\n                this.appearanceObserver.start();\r\n            }\r\n            this.linkInterceptor.start();\r\n            this.formInterceptor.start();\r\n            this.sourceURLChanged();\r\n        }\r\n    }\r\n    disconnect() {\r\n        if (this.connected) {\r\n            this.connected = false;\r\n            this.appearanceObserver.stop();\r\n            this.linkInterceptor.stop();\r\n            this.formInterceptor.stop();\r\n        }\r\n    }\r\n    disabledChanged() {\r\n        if (this.loadingStyle == FrameLoadingStyle.eager) {\r\n            this.loadSourceURL();\r\n        }\r\n    }\r\n    sourceURLChanged() {\r\n        if (this.loadingStyle == FrameLoadingStyle.eager || this.hasBeenLoaded) {\r\n            this.loadSourceURL();\r\n        }\r\n    }\r\n    loadingStyleChanged() {\r\n        if (this.loadingStyle == FrameLoadingStyle.lazy) {\r\n            this.appearanceObserver.start();\r\n        }\r\n        else {\r\n            this.appearanceObserver.stop();\r\n            this.loadSourceURL();\r\n        }\r\n    }\r\n    async loadSourceURL() {\r\n        if (!this.settingSourceURL && this.enabled && this.isActive && (this.reloadable || this.sourceURL != this.currentURL)) {\r\n            const previousURL = this.currentURL;\r\n            this.currentURL = this.sourceURL;\r\n            if (this.sourceURL) {\r\n                try {\r\n                    this.element.loaded = this.visit(expandURL(this.sourceURL));\r\n                    this.appearanceObserver.stop();\r\n                    await this.element.loaded;\r\n                    this.hasBeenLoaded = true;\r\n                }\r\n                catch (error) {\r\n                    this.currentURL = previousURL;\r\n                    throw error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    async loadResponse(fetchResponse) {\r\n        if (fetchResponse.redirected || (fetchResponse.succeeded && fetchResponse.isHTML)) {\r\n            this.sourceURL = fetchResponse.response.url;\r\n        }\r\n        try {\r\n            const html = await fetchResponse.responseHTML;\r\n            if (html) {\r\n                const { body } = parseHTMLDocument(html);\r\n                const snapshot = new Snapshot(await this.extractForeignFrameElement(body));\r\n                const renderer = new FrameRenderer(this.view.snapshot, snapshot, false, false);\r\n                if (this.view.renderPromise)\r\n                    await this.view.renderPromise;\r\n                await this.view.render(renderer);\r\n                session.frameRendered(fetchResponse, this.element);\r\n                session.frameLoaded(this.element);\r\n                this.fetchResponseLoaded(fetchResponse);\r\n            }\r\n        }\r\n        catch (error) {\r\n            console.error(error);\r\n            this.view.invalidate();\r\n        }\r\n        finally {\r\n            this.fetchResponseLoaded = () => { };\r\n        }\r\n    }\r\n    elementAppearedInViewport(element) {\r\n        this.loadSourceURL();\r\n    }\r\n    shouldInterceptLinkClick(element, url) {\r\n        if (element.hasAttribute(\"data-turbo-method\")) {\r\n            return false;\r\n        }\r\n        else {\r\n            return this.shouldInterceptNavigation(element);\r\n        }\r\n    }\r\n    linkClickIntercepted(element, url) {\r\n        this.reloadable = true;\r\n        this.navigateFrame(element, url);\r\n    }\r\n    shouldInterceptFormSubmission(element, submitter) {\r\n        return this.shouldInterceptNavigation(element, submitter);\r\n    }\r\n    formSubmissionIntercepted(element, submitter) {\r\n        if (this.formSubmission) {\r\n            this.formSubmission.stop();\r\n        }\r\n        this.reloadable = false;\r\n        this.formSubmission = new FormSubmission(this, element, submitter);\r\n        const { fetchRequest } = this.formSubmission;\r\n        this.prepareHeadersForRequest(fetchRequest.headers, fetchRequest);\r\n        this.formSubmission.start();\r\n    }\r\n    prepareHeadersForRequest(headers, request) {\r\n        headers[\"Turbo-Frame\"] = this.id;\r\n    }\r\n    requestStarted(request) {\r\n        markAsBusy(this.element);\r\n    }\r\n    requestPreventedHandlingResponse(request, response) {\r\n        this.resolveVisitPromise();\r\n    }\r\n    async requestSucceededWithResponse(request, response) {\r\n        await this.loadResponse(response);\r\n        this.resolveVisitPromise();\r\n    }\r\n    requestFailedWithResponse(request, response) {\r\n        console.error(response);\r\n        this.resolveVisitPromise();\r\n    }\r\n    requestErrored(request, error) {\r\n        console.error(error);\r\n        this.resolveVisitPromise();\r\n    }\r\n    requestFinished(request) {\r\n        clearBusyState(this.element);\r\n    }\r\n    formSubmissionStarted({ formElement }) {\r\n        markAsBusy(formElement, this.findFrameElement(formElement));\r\n    }\r\n    formSubmissionSucceededWithResponse(formSubmission, response) {\r\n        const frame = this.findFrameElement(formSubmission.formElement, formSubmission.submitter);\r\n        this.proposeVisitIfNavigatedWithAction(frame, formSubmission.formElement, formSubmission.submitter);\r\n        frame.delegate.loadResponse(response);\r\n    }\r\n    formSubmissionFailedWithResponse(formSubmission, fetchResponse) {\r\n        this.element.delegate.loadResponse(fetchResponse);\r\n    }\r\n    formSubmissionErrored(formSubmission, error) {\r\n        console.error(error);\r\n    }\r\n    formSubmissionFinished({ formElement }) {\r\n        clearBusyState(formElement, this.findFrameElement(formElement));\r\n    }\r\n    allowsImmediateRender(snapshot, resume) {\r\n        return true;\r\n    }\r\n    viewRenderedSnapshot(snapshot, isPreview) {\r\n    }\r\n    viewInvalidated() {\r\n    }\r\n    async visit(url) {\r\n        var _a;\r\n        const request = new FetchRequest(this, FetchMethod.get, url, new URLSearchParams, this.element);\r\n        (_a = this.currentFetchRequest) === null || _a === void 0 ? void 0 : _a.cancel();\r\n        this.currentFetchRequest = request;\r\n        return new Promise(resolve => {\r\n            this.resolveVisitPromise = () => {\r\n                this.resolveVisitPromise = () => { };\r\n                this.currentFetchRequest = null;\r\n                resolve();\r\n            };\r\n            request.perform();\r\n        });\r\n    }\r\n    navigateFrame(element, url, submitter) {\r\n        const frame = this.findFrameElement(element, submitter);\r\n        this.proposeVisitIfNavigatedWithAction(frame, element, submitter);\r\n        frame.setAttribute(\"reloadable\", \"\");\r\n        frame.src = url;\r\n    }\r\n    proposeVisitIfNavigatedWithAction(frame, element, submitter) {\r\n        const action = getAttribute(\"data-turbo-action\", submitter, element, frame);\r\n        if (isAction(action)) {\r\n            const { visitCachedSnapshot } = new SnapshotSubstitution(frame);\r\n            frame.delegate.fetchResponseLoaded = (fetchResponse) => {\r\n                if (frame.src) {\r\n                    const { statusCode, redirected } = fetchResponse;\r\n                    const responseHTML = frame.ownerDocument.documentElement.outerHTML;\r\n                    const response = { statusCode, redirected, responseHTML };\r\n                    session.visit(frame.src, { action, response, visitCachedSnapshot, willRender: false });\r\n                }\r\n            };\r\n        }\r\n    }\r\n    findFrameElement(element, submitter) {\r\n        var _a;\r\n        const id = getAttribute(\"data-turbo-frame\", submitter, element) || this.element.getAttribute(\"target\");\r\n        return (_a = getFrameElementById(id)) !== null && _a !== void 0 ? _a : this.element;\r\n    }\r\n    async extractForeignFrameElement(container) {\r\n        let element;\r\n        const id = CSS.escape(this.id);\r\n        try {\r\n            if (element = activateElement(container.querySelector(`turbo-frame#${id}`), this.currentURL)) {\r\n                return element;\r\n            }\r\n            if (element = activateElement(container.querySelector(`turbo-frame[src][recurse~=${id}]`), this.currentURL)) {\r\n                await element.loaded;\r\n                return await this.extractForeignFrameElement(element);\r\n            }\r\n            console.error(`Response has no matching <turbo-frame id=\"${id}\"> element`);\r\n        }\r\n        catch (error) {\r\n            console.error(error);\r\n        }\r\n        return new FrameElement();\r\n    }\r\n    formActionIsVisitable(form, submitter) {\r\n        const action = getAction(form, submitter);\r\n        return locationIsVisitable(expandURL(action), this.rootLocation);\r\n    }\r\n    shouldInterceptNavigation(element, submitter) {\r\n        const id = getAttribute(\"data-turbo-frame\", submitter, element) || this.element.getAttribute(\"target\");\r\n        if (element instanceof HTMLFormElement && !this.formActionIsVisitable(element, submitter)) {\r\n            return false;\r\n        }\r\n        if (!this.enabled || id == \"_top\") {\r\n            return false;\r\n        }\r\n        if (id) {\r\n            const frameElement = getFrameElementById(id);\r\n            if (frameElement) {\r\n                return !frameElement.disabled;\r\n            }\r\n        }\r\n        if (!session.elementDriveEnabled(element)) {\r\n            return false;\r\n        }\r\n        if (submitter && !session.elementDriveEnabled(submitter)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    get id() {\r\n        return this.element.id;\r\n    }\r\n    get enabled() {\r\n        return !this.element.disabled;\r\n    }\r\n    get sourceURL() {\r\n        if (this.element.src) {\r\n            return this.element.src;\r\n        }\r\n    }\r\n    get reloadable() {\r\n        const frame = this.findFrameElement(this.element);\r\n        return frame.hasAttribute(\"reloadable\");\r\n    }\r\n    set reloadable(value) {\r\n        const frame = this.findFrameElement(this.element);\r\n        if (value) {\r\n            frame.setAttribute(\"reloadable\", \"\");\r\n        }\r\n        else {\r\n            frame.removeAttribute(\"reloadable\");\r\n        }\r\n    }\r\n    set sourceURL(sourceURL) {\r\n        this.settingSourceURL = true;\r\n        this.element.src = sourceURL !== null && sourceURL !== void 0 ? sourceURL : null;\r\n        this.currentURL = this.element.src;\r\n        this.settingSourceURL = false;\r\n    }\r\n    get loadingStyle() {\r\n        return this.element.loading;\r\n    }\r\n    get isLoading() {\r\n        return this.formSubmission !== undefined || this.resolveVisitPromise() !== undefined;\r\n    }\r\n    get isActive() {\r\n        return this.element.isActive && this.connected;\r\n    }\r\n    get rootLocation() {\r\n        var _a;\r\n        const meta = this.element.ownerDocument.querySelector(`meta[name=\"turbo-root\"]`);\r\n        const root = (_a = meta === null || meta === void 0 ? void 0 : meta.content) !== null && _a !== void 0 ? _a : \"/\";\r\n        return expandURL(root);\r\n    }\r\n}\r\nclass SnapshotSubstitution {\r\n    constructor(element) {\r\n        this.visitCachedSnapshot = ({ element }) => {\r\n            var _a;\r\n            const { id, clone } = this;\r\n            (_a = element.querySelector(\"#\" + id)) === null || _a === void 0 ? void 0 : _a.replaceWith(clone);\r\n        };\r\n        this.clone = element.cloneNode(true);\r\n        this.id = element.id;\r\n    }\r\n}\r\nfunction getFrameElementById(id) {\r\n    if (id != null) {\r\n        const element = document.getElementById(id);\r\n        if (element instanceof FrameElement) {\r\n            return element;\r\n        }\r\n    }\r\n}\r\nfunction activateElement(element, currentURL) {\r\n    if (element) {\r\n        const src = element.getAttribute(\"src\");\r\n        if (src != null && currentURL != null && urlsAreEqual(src, currentURL)) {\r\n            throw new Error(`Matching <turbo-frame id=\"${element.id}\"> element has a source URL which references itself`);\r\n        }\r\n        if (element.ownerDocument !== document) {\r\n            element = document.importNode(element, true);\r\n        }\r\n        if (element instanceof FrameElement) {\r\n            element.connectedCallback();\r\n            element.disconnectedCallback();\r\n            return element;\r\n        }\r\n    }\r\n}\r\n\r\nconst StreamActions = {\r\n    after() {\r\n        this.targetElements.forEach(e => { var _a; return (_a = e.parentElement) === null || _a === void 0 ? void 0 : _a.insertBefore(this.templateContent, e.nextSibling); });\r\n    },\r\n    append() {\r\n        this.removeDuplicateTargetChildren();\r\n        this.targetElements.forEach(e => e.append(this.templateContent));\r\n    },\r\n    before() {\r\n        this.targetElements.forEach(e => { var _a; return (_a = e.parentElement) === null || _a === void 0 ? void 0 : _a.insertBefore(this.templateContent, e); });\r\n    },\r\n    prepend() {\r\n        this.removeDuplicateTargetChildren();\r\n        this.targetElements.forEach(e => e.prepend(this.templateContent));\r\n    },\r\n    remove() {\r\n        this.targetElements.forEach(e => e.remove());\r\n    },\r\n    replace() {\r\n        this.targetElements.forEach(e => e.replaceWith(this.templateContent));\r\n    },\r\n    update() {\r\n        this.targetElements.forEach(e => {\r\n            e.innerHTML = \"\";\r\n            e.append(this.templateContent);\r\n        });\r\n    }\r\n};\r\n\r\nclass StreamElement extends HTMLElement {\r\n    async connectedCallback() {\r\n        try {\r\n            await this.render();\r\n        }\r\n        catch (error) {\r\n            console.error(error);\r\n        }\r\n        finally {\r\n            this.disconnect();\r\n        }\r\n    }\r\n    async render() {\r\n        var _a;\r\n        return (_a = this.renderPromise) !== null && _a !== void 0 ? _a : (this.renderPromise = (async () => {\r\n            if (this.dispatchEvent(this.beforeRenderEvent)) {\r\n                await nextAnimationFrame();\r\n                this.performAction();\r\n            }\r\n        })());\r\n    }\r\n    disconnect() {\r\n        try {\r\n            this.remove();\r\n        }\r\n        catch (_a) { }\r\n    }\r\n    removeDuplicateTargetChildren() {\r\n        this.duplicateChildren.forEach(c => c.remove());\r\n    }\r\n    get duplicateChildren() {\r\n        var _a;\r\n        const existingChildren = this.targetElements.flatMap(e => [...e.children]).filter(c => !!c.id);\r\n        const newChildrenIds = [...(_a = this.templateContent) === null || _a === void 0 ? void 0 : _a.children].filter(c => !!c.id).map(c => c.id);\r\n        return existingChildren.filter(c => newChildrenIds.includes(c.id));\r\n    }\r\n    get performAction() {\r\n        if (this.action) {\r\n            const actionFunction = StreamActions[this.action];\r\n            if (actionFunction) {\r\n                return actionFunction;\r\n            }\r\n            this.raise(\"unknown action\");\r\n        }\r\n        this.raise(\"action attribute is missing\");\r\n    }\r\n    get targetElements() {\r\n        if (this.target) {\r\n            return this.targetElementsById;\r\n        }\r\n        else if (this.targets) {\r\n            return this.targetElementsByQuery;\r\n        }\r\n        else {\r\n            this.raise(\"target or targets attribute is missing\");\r\n        }\r\n    }\r\n    get templateContent() {\r\n        return this.templateElement.content.cloneNode(true);\r\n    }\r\n    get templateElement() {\r\n        if (this.firstElementChild instanceof HTMLTemplateElement) {\r\n            return this.firstElementChild;\r\n        }\r\n        this.raise(\"first child element must be a <template> element\");\r\n    }\r\n    get action() {\r\n        return this.getAttribute(\"action\");\r\n    }\r\n    get target() {\r\n        return this.getAttribute(\"target\");\r\n    }\r\n    get targets() {\r\n        return this.getAttribute(\"targets\");\r\n    }\r\n    raise(message) {\r\n        throw new Error(`${this.description}: ${message}`);\r\n    }\r\n    get description() {\r\n        var _a, _b;\r\n        return (_b = ((_a = this.outerHTML.match(/<[^>]+>/)) !== null && _a !== void 0 ? _a : [])[0]) !== null && _b !== void 0 ? _b : \"<turbo-stream>\";\r\n    }\r\n    get beforeRenderEvent() {\r\n        return new CustomEvent(\"turbo:before-stream-render\", { bubbles: true, cancelable: true });\r\n    }\r\n    get targetElementsById() {\r\n        var _a;\r\n        const element = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.getElementById(this.target);\r\n        if (element !== null) {\r\n            return [element];\r\n        }\r\n        else {\r\n            return [];\r\n        }\r\n    }\r\n    get targetElementsByQuery() {\r\n        var _a;\r\n        const elements = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.querySelectorAll(this.targets);\r\n        if (elements.length !== 0) {\r\n            return Array.prototype.slice.call(elements);\r\n        }\r\n        else {\r\n            return [];\r\n        }\r\n    }\r\n}\r\n\r\nFrameElement.delegateConstructor = FrameController;\r\ncustomElements.define(\"turbo-frame\", FrameElement);\r\ncustomElements.define(\"turbo-stream\", StreamElement);\r\n\r\n(() => {\r\n    let element = document.currentScript;\r\n    if (!element)\r\n        return;\r\n    if (element.hasAttribute(\"data-turbo-suppress-warning\"))\r\n        return;\r\n    while (element = element.parentElement) {\r\n        if (element == document.body) {\r\n            return console.warn(unindent `\r\n        You are loading Turbo from a <script> element inside the <body> element. This is probably not what you meant to do!\r\n\r\n        Load your applicationâs JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.\r\n\r\n        For more information, see: https://turbo.hotwired.dev/handbook/building#working-with-script-elements\r\n\r\n        ââ\r\n        Suppress this warning by adding a \"data-turbo-suppress-warning\" attribute to: %s\r\n      `, element.outerHTML);\r\n        }\r\n    }\r\n})();\r\n\r\nwindow.Turbo = Turbo;\r\nstart();\r\n\r\nexport { PageRenderer, PageSnapshot, clearCache, connectStreamSource, disconnectStreamSource, navigator$1 as navigator, registerAdapter, renderStreamMessage, session, setConfirmMethod, setProgressBarDelay, start, visit };\r\n","// extracted by mini-css-extract-plugin\nexport {};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import '../css/app.css';\r\n\r\nimport * as Turbo from '@hotwired/turbo'\r\n\r\n// Turns Turbo Drive on/off (default on). \r\n// If off, we must opt-in to Turbo Drive on a per-link and per-form basis using data-turbo=\"true\".\r\nTurbo.session.drive = true\r\n\r\n// Turbo event listeners\r\ndocument.addEventListener('turbo:load', function (e) {\r\n    console.log('turbo:load', e);\r\n});\r\n\r\ndocument.addEventListener('turbo:visit', function (e) {\r\n    console.log('turbo:visit', e);\r\n});\r\n\r\ndocument.addEventListener('turbo:frame-load', function (e) {\r\n    console.log('turbo:frame-load', e);\r\n});"],"names":["Turbo","session","drive","document","addEventListener","e","console","log"],"sourceRoot":""}